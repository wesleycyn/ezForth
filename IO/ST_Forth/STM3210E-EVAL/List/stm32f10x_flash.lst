###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.20.0.50892/W32 for ARM     07/Oct/2009  13:03:56 #
# Copyright 1999-2008 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f #
#                    10x_flash.c                                              #
#    Command line =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f #
#                    10x_flash.c -D VECT_TAB_FLASH -lC                        #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\List #
#                    \ -o F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL #
#                    \Obj\ --debug --endian=little --cpu=Cortex-M3 -e         #
#                    --char_is_signed --require_prototypes --fpu=None         #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.0\ARM\INC\DLib_Config_Full.h" -I             #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\ -I                #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\inc\ -I    #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.0\ARM\INC\" --section .text=FastProcRAM -Ohz           #
#    List file    =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\List #
#                    \stm32f10x_flash.lst                                     #
#    Object file  =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\Obj\ #
#                    stm32f10x_flash.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f10x_flash.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_flash.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the FLASH firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_flash.h"
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          /* Flash Access Control Register bits */
     22          #define ACR_LATENCY_Mask         ((u32)0x00000038)
     23          #define ACR_HLFCYA_Mask          ((u32)0xFFFFFFF7)
     24          #define ACR_PRFTBE_Mask          ((u32)0xFFFFFFEF)
     25          
     26          #ifdef _FLASH_PROG
     27          /* Flash Access Control Register bits */
     28          #define ACR_PRFTBS_Mask          ((u32)0x00000020) 
     29          
     30          /* Flash Control Register bits */
     31          #define CR_PG_Set                ((u32)0x00000001)
     32          #define CR_PG_Reset              ((u32)0x00001FFE) 
     33          
     34          #define CR_PER_Set               ((u32)0x00000002)
     35          #define CR_PER_Reset             ((u32)0x00001FFD)
     36          
     37          #define CR_MER_Set               ((u32)0x00000004)
     38          #define CR_MER_Reset             ((u32)0x00001FFB)
     39          
     40          #define CR_OPTPG_Set             ((u32)0x00000010)
     41          #define CR_OPTPG_Reset           ((u32)0x00001FEF)
     42          
     43          #define CR_OPTER_Set             ((u32)0x00000020)
     44          #define CR_OPTER_Reset           ((u32)0x00001FDF)
     45          
     46          #define CR_STRT_Set              ((u32)0x00000040)
     47          							 
     48          #define CR_LOCK_Set              ((u32)0x00000080)
     49          
     50          /* FLASH Mask */
     51          #define RDPRT_Mask               ((u32)0x00000002)
     52          #define WRP0_Mask                ((u32)0x000000FF)
     53          #define WRP1_Mask                ((u32)0x0000FF00)
     54          #define WRP2_Mask                ((u32)0x00FF0000)
     55          #define WRP3_Mask                ((u32)0xFF000000)
     56          
     57          /* FLASH Keys */
     58          #define RDP_Key                  ((u16)0x00A5)
     59          #define FLASH_KEY1               ((u32)0x45670123)
     60          #define FLASH_KEY2               ((u32)0xCDEF89AB)
     61          
     62          /* Delay definition */   
     63          #define EraseTimeout             ((u32)0x00000FFF)
     64          #define ProgramTimeout           ((u32)0x0000000F)
     65          #endif
     66          
     67          /* Private macro -------------------------------------------------------------*/
     68          /* Private variables ---------------------------------------------------------*/
     69          /* Private function prototypes -----------------------------------------------*/
     70          #ifdef _FLASH_PROG
     71          static void delay(void);
     72          #endif
     73          
     74          /* Private functions ---------------------------------------------------------*/
     75          /*******************************************************************************
     76          * Function Name  : FLASH_SetLatency
     77          * Description    : Sets the code latency value.
     78          * Input          : - FLASH_Latency: specifies the FLASH Latency value.
     79          *                    This parameter can be one of the following values:
     80          *                       - FLASH_Latency_0: FLASH Zero Latency cycle
     81          *                       - FLASH_Latency_1: FLASH One Latency cycle
     82          *                       - FLASH_Latency_2: FLASH Two Latency cycles
     83          * Output         : None
     84          * Return         : None
     85          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
     86          void FLASH_SetLatency(u32 FLASH_Latency)  @"FastProcRAM"
     87          {
     88            /* Check the parameters */
     89            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
     90            
     91            /* Sets the Latency value */
     92            FLASH->ACR &= ACR_LATENCY_Mask;
   \                     FLASH_SetLatency:
   \   00000000   ....               LDR.N    R1,??DataTable2  ;; 0x40022000
   \   00000002   0A68               LDR      R2,[R1, #+0]
   \   00000004   02F03802           AND      R2,R2,#0x38
   \   00000008   ....               B.N      ??Subroutine1_0
     93            FLASH->ACR |= FLASH_Latency;
     94          }

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??Subroutine1_0:
   \   00000000   0A60               STR      R2,[R1, #+0]
   \   00000002   0A68               LDR      R2,[R1, #+0]
   \   00000004   1043               ORRS     R0,R0,R2
   \   00000006   0860               STR      R0,[R1, #+0]
   \   00000008   7047               BX       LR               ;; return
     95          
     96          /*******************************************************************************
     97          * Function Name  : FLASH_HalfCycleAccessCmd
     98          * Description    : Enables or disables the Half cycle flash access.
     99          * Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
    100          *                    This parameter can be one of the following values:
    101          *                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
    102          *                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
    103          * Output         : None
    104          * Return         : None
    105          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    106          void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)  @"FastProcRAM"
    107          {
    108            /* Check the parameters */
    109            assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
    110            
    111            /* Enable or disable the Half cycle access */
    112            FLASH->ACR &= ACR_HLFCYA_Mask;
   \                     FLASH_HalfCycleAccessCmd:
   \   00000000   ....               LDR.N    R1,??DataTable2  ;; 0x40022000
   \   00000002   0A68               LDR      R2,[R1, #+0]
   \   00000004   0823               MOVS     R3,#+8
   \   00000006   ....               B.N      ?Subroutine0
    113            FLASH->ACR |= FLASH_HalfCycleAccess;
    114          }

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   9A43               BICS     R2,R2,R3
   \   00000002   00BF               Nop      
   \   00000004                      REQUIRE ??Subroutine1_0
   \   00000004                      ;; // Fall through to label ??Subroutine1_0
    115          
    116          /*******************************************************************************
    117          * Function Name  : FLASH_PrefetchBufferCmd
    118          * Description    : Enables or disables the Prefetch Buffer.
    119          * Input          : - FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
    120          *                    This parameter can be one of the following values:
    121          *                       - FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
    122          *                       - FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
    123          * Output         : None
    124          * Return         : None
    125          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    126          void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)  @"FastProcRAM"
    127          {
    128            /* Check the parameters */
    129            assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
    130            
    131            /* Enable or disable the Prefetch Buffer */
    132            FLASH->ACR &= ACR_PRFTBE_Mask;
   \                     FLASH_PrefetchBufferCmd:
   \   00000000   ....               LDR.N    R1,??DataTable2  ;; 0x40022000
   \   00000002   0A68               LDR      R2,[R1, #+0]
   \   00000004   1023               MOVS     R3,#+16
   \   00000006   00BF               Nop      
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    133            FLASH->ACR |= FLASH_PrefetchBuffer;
    134          }
    135          
    136          #ifdef _FLASH_PROG
    137          /*******************************************************************************
    138          * Function Name  : FLASH_Unlock
    139          * Description    : Unlocks the FLASH Program Erase Controller.
    140          * Input          : None
    141          * Output         : None
    142          * Return         : None
    143          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    144          void FLASH_Unlock(void)  @"FastProcRAM"
    145          {
    146            /* Authorize the FPEC Access */
    147            FLASH->KEYR = FLASH_KEY1;
   \                     FLASH_Unlock:
   \   00000000   0248               LDR.N    R0,??FLASH_Unlock_0  ;; 0x40022004
   \   00000002   0349               LDR.N    R1,??FLASH_Unlock_0+0x4  ;; 0x45670123
   \   00000004   0160               STR      R1,[R0, #+0]
    148            FLASH->KEYR = FLASH_KEY2;
   \   00000006   0349               LDR.N    R1,??FLASH_Unlock_0+0x8  ;; 0xcdef89ab
   \   00000008   0160               STR      R1,[R0, #+0]
    149          }
   \   0000000A   7047               BX       LR               ;; return
   \                     ??FLASH_Unlock_0:
   \   0000000C   04200240           DC32     0x40022004
   \   00000010   23016745           DC32     0x45670123
   \   00000014   AB89EFCD           DC32     0xcdef89ab
    150          
    151          /*******************************************************************************
    152          * Function Name  : FLASH_Lock
    153          * Description    : Locks the FLASH Program Erase Controller.
    154          * Input          : None
    155          * Output         : None
    156          * Return         : None
    157          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    158          void FLASH_Lock(void)  @"FastProcRAM"
    159          {
    160            /* Set the Lock Bit to lock the FPEC and the FCR */
    161            FLASH->CR |= CR_LOCK_Set;
   \                     FLASH_Lock:
   \   00000000   0248               LDR.N    R0,??FLASH_Lock_0  ;; 0x40022010
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   41F08001           ORR      R1,R1,#0x80
   \   00000008   0160               STR      R1,[R0, #+0]
    162          }
   \   0000000A   7047               BX       LR               ;; return
   \                     ??FLASH_Lock_0:
   \   0000000C   10200240           DC32     0x40022010
    163          
    164          /*******************************************************************************
    165          * Function Name  : FLASH_ErasePage
    166          * Description    : Erases a specified FLASH page.
    167          * Input          : - Page_Address: The page address to be erased.
    168          * Output         : None
    169          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    170          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    171          *                  FLASH_TIMEOUT.
    172          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    173          FLASH_Status FLASH_ErasePage(u32 Page_Address)  //@"FastProcRAM"
    174          {
   \                     FLASH_ErasePage:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
    175            FLASH_Status status = FLASH_COMPLETE;
    176          
    177            /* Check the parameters */
    178            assert_param(IS_FLASH_ADDRESS(Page_Address));
    179          
    180            /* Wait for last operation to be completed */
    181            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000004   40F6FF74           MOVW     R4,#+4095
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       FLASH_WaitForLastOperation
    182            
    183            if(status == FLASH_COMPLETE)
   \   0000000E   0428               CMP      R0,#+4
   \   00000010   14D1               BNE.N    ??FLASH_ErasePage_0
    184            { 
    185              /* if the previous operation is completed, proceed to erase the page */
    186              FLASH->CR|= CR_PER_Set;
   \   00000012   ........           LDR.W    R5,??DataTable50  ;; 0x40022010
   \   00000016   2868               LDR      R0,[R5, #+0]
   \   00000018   40F00200           ORR      R0,R0,#0x2
   \   0000001C   2860               STR      R0,[R5, #+0]
    187              FLASH->AR = Page_Address; 
   \   0000001E   6E60               STR      R6,[R5, #+4]
    188              FLASH->CR|= CR_STRT_Set;
   \   00000020   2868               LDR      R0,[R5, #+0]
   \   00000022   40F04000           ORR      R0,R0,#0x40
   \   00000026   2860               STR      R0,[R5, #+0]
    189              
    190              /* Wait for last operation to be completed */
    191              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       FLASH_WaitForLastOperation
    192          
    193              if(status != FLASH_BUSY)
   \   0000002E   0128               CMP      R0,#+1
   \   00000030   04D0               BEQ.N    ??FLASH_ErasePage_0
    194              {
    195                /* if the erase operation is completed, disable the PER Bit */
    196                FLASH->CR &= CR_PER_Reset;
   \   00000032   2968               LDR      R1,[R5, #+0]
   \   00000034   41F6FD72           MOVW     R2,#+8189
   \   00000038   1140               ANDS     R1,R2,R1
   \   0000003A   2960               STR      R1,[R5, #+0]
    197              }
    198            }
    199            /* Return the Erase Status */
    200            return status;
   \                     ??FLASH_ErasePage_0:
   \   0000003C   70BD               POP      {R4-R6,PC}       ;; return
    201          }
    202          
    203          /*******************************************************************************
    204          * Function Name  : FLASH_EraseAllPages
    205          * Description    : Erases all FLASH pages.
    206          * Input          : None
    207          * Output         : None
    208          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    209          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    210          *                  FLASH_TIMEOUT.
    211          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    212          FLASH_Status FLASH_EraseAllPages(void)  //@"FastProcRAM"
    213          {
   \                     FLASH_EraseAllPages:
   \   00000000   38B5               PUSH     {R3-R5,LR}
    214            FLASH_Status status = FLASH_COMPLETE;
    215          
    216            /* Wait for last operation to be completed */
    217            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000002   40F6FF75           MOVW     R5,#+4095
   \   00000006   2800               MOVS     R0,R5
   \   00000008   ........           BL       FLASH_WaitForLastOperation
    218            
    219            if(status == FLASH_COMPLETE)
   \   0000000C   0428               CMP      R0,#+4
   \   0000000E   12D1               BNE.N    ??FLASH_EraseAllPages_0
    220            {
    221              /* if the previous operation is completed, proceed to erase all pages */
    222               FLASH->CR |= CR_MER_Set;
   \   00000010   ....               LDR.N    R4,??DataTable50  ;; 0x40022010
   \   00000012   2068               LDR      R0,[R4, #+0]
   \   00000014   40F00400           ORR      R0,R0,#0x4
   \   00000018   2060               STR      R0,[R4, #+0]
    223               FLASH->CR |= CR_STRT_Set;
   \   0000001A   2068               LDR      R0,[R4, #+0]
   \   0000001C   40F04000           ORR      R0,R0,#0x40
   \   00000020   2060               STR      R0,[R4, #+0]
    224              
    225              /* Wait for last operation to be completed */
    226              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000022   2800               MOVS     R0,R5
   \   00000024   ........           BL       FLASH_WaitForLastOperation
    227          
    228              if(status != FLASH_BUSY)
   \   00000028   0128               CMP      R0,#+1
   \   0000002A   04D0               BEQ.N    ??FLASH_EraseAllPages_0
    229              {
    230                /* if the erase operation is completed, disable the MER Bit */
    231                FLASH->CR &= CR_MER_Reset;
   \   0000002C   2168               LDR      R1,[R4, #+0]
   \   0000002E   41F6FB72           MOVW     R2,#+8187
   \   00000032   1140               ANDS     R1,R2,R1
   \   00000034   2160               STR      R1,[R4, #+0]
    232              }
    233            }	   
    234            /* Return the Erase Status */
    235            return status;
   \                     ??FLASH_EraseAllPages_0:
   \   00000036   32BD               POP      {R1,R4,R5,PC}    ;; return
    236          }
    237          
    238          /*******************************************************************************
    239          * Function Name  : FLASH_EraseOptionBytes
    240          * Description    : Erases the FLASH option bytes.
    241          * Input          : None
    242          * Output         : None
    243          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    244          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    245          *                  FLASH_TIMEOUT.
    246          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    247          FLASH_Status FLASH_EraseOptionBytes(void)  //@"FastProcRAM"
    248          {
   \                     FLASH_EraseOptionBytes:
   \   00000000   10B5               PUSH     {R4,LR}
    249            FLASH_Status status = FLASH_COMPLETE;
    250            
    251            /* Wait for last operation to be completed */
    252            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000002   40F6FF74           MOVW     R4,#+4095
   \   00000006   2000               MOVS     R0,R4
   \   00000008   ........           BL       FLASH_WaitForLastOperation
    253          
    254            if(status == FLASH_COMPLETE)
   \   0000000C   0428               CMP      R0,#+4
   \   0000000E   33D1               BNE.N    ??FLASH_EraseOptionBytes_0
    255            {
    256              /* Authorize the small information block programming */
    257              FLASH->OPTKEYR = FLASH_KEY1;
   \   00000010   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   00000012   ....               LDR.N    R1,??DataTable42  ;; 0x45670123
   \   00000014   0160               STR      R1,[R0, #+0]
    258              FLASH->OPTKEYR = FLASH_KEY2;
   \   00000016   ....               LDR.N    R1,??DataTable43  ;; 0xcdef89ab
   \   00000018   0160               STR      R1,[R0, #+0]
    259              
    260              /* if the previous operation is completed, proceed to erase the option bytes */
    261              FLASH->CR |= CR_OPTER_Set;
   \   0000001A   8068               LDR      R0,[R0, #+8]
   \   0000001C   40F02000           ORR      R0,R0,#0x20
   \   00000020   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000022   8860               STR      R0,[R1, #+8]
    262              FLASH->CR |= CR_STRT_Set;
   \   00000024   8868               LDR      R0,[R1, #+8]
   \   00000026   40F04000           ORR      R0,R0,#0x40
   \   0000002A   8860               STR      R0,[R1, #+8]
    263          
    264              /* Wait for last operation to be completed */
    265              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       FLASH_WaitForLastOperation
    266              
    267              if(status == FLASH_COMPLETE)
   \   00000032   41F6EF74           MOVW     R4,#+8175
   \   00000036   0428               CMP      R0,#+4
   \   00000038   17D1               BNE.N    ??FLASH_EraseOptionBytes_1
    268              {
    269                /* if the erase operation is completed, disable the OPTER Bit */
    270                FLASH->CR &= CR_OPTER_Reset;
   \   0000003A   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   0000003C   8068               LDR      R0,[R0, #+8]
   \   0000003E   41F6DF71           MOVW     R1,#+8159
   \   00000042   0840               ANDS     R0,R1,R0
   \   00000044   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000046   8860               STR      R0,[R1, #+8]
    271                 
    272                /* Enable the Option Bytes Programming operation */
    273                FLASH->CR |= CR_OPTPG_Set;
   \   00000048   8868               LDR      R0,[R1, #+8]
   \   0000004A   40F01000           ORR      R0,R0,#0x10
   \   0000004E   8860               STR      R0,[R1, #+8]
    274          
    275                /* Enable the readout access */
    276                OB->RDP= RDP_Key; 
   \   00000050   ....               LDR.N    R0,??DataTable36  ;; 0x1ffff800
   \   00000052   A521               MOVS     R1,#+165
   \   00000054   0180               STRH     R1,[R0, #+0]
    277          
    278                /* Wait for last operation to be completed */
    279                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000056   0F20               MOVS     R0,#+15
   \   00000058   ........           BL       FLASH_WaitForLastOperation
    280           
    281                if(status != FLASH_BUSY)
   \   0000005C   0128               CMP      R0,#+1
   \   0000005E   0BD0               BEQ.N    ??FLASH_EraseOptionBytes_0
    282                {
    283                  /* if the program operation is completed, disable the OPTPG Bit */
    284                  FLASH->CR &= CR_OPTPG_Reset;
   \   00000060   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000062   8968               LDR      R1,[R1, #+8]
   \   00000064   2140               ANDS     R1,R4,R1
   \   00000066   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   00000068   05E0               B.N      ??FLASH_EraseOptionBytes_2
    285                }
    286              }
    287              else
    288              {
    289                if (status != FLASH_BUSY)
   \                     ??FLASH_EraseOptionBytes_1:
   \   0000006A   0128               CMP      R0,#+1
   \   0000006C   04D0               BEQ.N    ??FLASH_EraseOptionBytes_0
    290                {
    291                  /* Disable the OPTPG Bit */
    292                  FLASH->CR &= CR_OPTPG_Reset;
   \   0000006E   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000070   8968               LDR      R1,[R1, #+8]
   \   00000072   2140               ANDS     R1,R4,R1
   \   00000074   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \                     ??FLASH_EraseOptionBytes_2:
   \   00000076   9160               STR      R1,[R2, #+8]
    293                }
    294              }  
    295            }
    296            /* Return the erase status */
    297            return status;
   \                     ??FLASH_EraseOptionBytes_0:
   \   00000078   10BD               POP      {R4,PC}          ;; return
    298          }
    299          
    300          /*******************************************************************************
    301          * Function Name  : FLASH_ProgramWord
    302          * Description    : Programs a word at a specified address.
    303          * Input          : - Address: specifies the address to be programmed.
    304          *                  - Data: specifies the data to be programmed.
    305          * Output         : None
    306          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    307          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    308          *                  FLASH_TIMEOUT. 
    309          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    310          FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)  //@"FastProcRAM"
    311          {
   \                     FLASH_ProgramWord:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    312            FLASH_Status status = FLASH_COMPLETE;
    313          
    314            /* Check the parameters */
    315            assert_param(IS_FLASH_ADDRESS(Address));
    316          
    317            /* Wait for last operation to be completed */
    318            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000006   0F20               MOVS     R0,#+15
   \   00000008   ........           BL       FLASH_WaitForLastOperation
    319            
    320            if(status == FLASH_COMPLETE)
   \   0000000C   0428               CMP      R0,#+4
   \   0000000E   16D1               BNE.N    ??FLASH_ProgramWord_0
    321            {
    322              /* if the previous operation is completed, proceed to program the new first 
    323              half word */
    324              FLASH->CR |= CR_PG_Set;
   \   00000010   ....               LDR.N    R6,??DataTable50  ;; 0x40022010
   \   00000012   3068               LDR      R0,[R6, #+0]
   \   00000014   40F00100           ORR      R0,R0,#0x1
   \   00000018   3060               STR      R0,[R6, #+0]
    325            
    326              *(vu16*)Address = (u16)Data;
   \   0000001A   2C80               STRH     R4,[R5, #+0]
    327          
    328              /* Wait for last operation to be completed */
    329              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000001C   0F20               MOVS     R0,#+15
   \   0000001E   ........           BL       FLASH_WaitForLastOperation
    330           
    331              if(status == FLASH_COMPLETE)
   \   00000022   41F6FE77           MOVW     R7,#+8190
   \   00000026   0428               CMP      R0,#+4
   \   00000028   04D1               BNE.N    ??FLASH_ProgramWord_1
    332              {
    333                /* if the previous operation is completed, proceed to program the new second 
    334                half word */
    335                *(vu16*)(Address + 2) = Data >> 16;
   \   0000002A   200C               LSRS     R0,R4,#+16
   \   0000002C   6880               STRH     R0,[R5, #+2]
    336              
    337                /* Wait for last operation to be completed */
    338                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000002E   0F20               MOVS     R0,#+15
   \   00000030   ........           BL       FLASH_WaitForLastOperation
    339                  
    340                if(status != FLASH_BUSY)
    341                {
    342                  /* Disable the PG Bit */
    343                  FLASH->CR &= CR_PG_Reset;
    344                }
    345              }
    346              else
    347              {
    348                if (status != FLASH_BUSY)
   \                     ??FLASH_ProgramWord_1:
   \   00000034   0128               CMP      R0,#+1
   \   00000036   02D0               BEQ.N    ??FLASH_ProgramWord_0
    349                {
    350                  /* Disable the PG Bit */
    351                  FLASH->CR &= CR_PG_Reset;
   \   00000038   3168               LDR      R1,[R6, #+0]
   \   0000003A   3940               ANDS     R1,R7,R1
   \   0000003C   3160               STR      R1,[R6, #+0]
    352                }
    353               }
    354            }
    355            /* Return the Program Status */
    356            return status;
   \                     ??FLASH_ProgramWord_0:
   \   0000003E   F2BD               POP      {R1,R4-R7,PC}    ;; return
    357          }
    358          
    359          /*******************************************************************************
    360          * Function Name  : FLASH_ProgramHalfWord
    361          * Description    : Programs a half word at a specified address.
    362          * Input          : - Address: specifies the address to be programmed.
    363          *                  - Data: specifies the data to be programmed.
    364          * Output         : None
    365          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    366          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    367          *                  FLASH_TIMEOUT. 
    368          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    369          FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)  //@"FastProcRAM"
    370          {
   \                     FLASH_ProgramHalfWord:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
    371            FLASH_Status status = FLASH_COMPLETE;
    372          
    373            /* Check the parameters */
    374            assert_param(IS_FLASH_ADDRESS(Address));
    375          
    376            /* Wait for last operation to be completed */
    377            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000006   0F20               MOVS     R0,#+15
   \   00000008   ........           BL       FLASH_WaitForLastOperation
    378            
    379            if(status == FLASH_COMPLETE)
   \   0000000C   0428               CMP      R0,#+4
   \   0000000E   0FD1               BNE.N    ??FLASH_ProgramHalfWord_0
    380            {
    381              /* if the previous operation is completed, proceed to program the new data */
    382              FLASH->CR |= CR_PG_Set;
   \   00000010   ....               LDR.N    R5,??DataTable50  ;; 0x40022010
   \   00000012   2868               LDR      R0,[R5, #+0]
   \   00000014   40F00100           ORR      R0,R0,#0x1
   \   00000018   2860               STR      R0,[R5, #+0]
    383            
    384              *(vu16*)Address = Data;
   \   0000001A   3480               STRH     R4,[R6, #+0]
    385              /* Wait for last operation to be completed */
    386              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000001C   0F20               MOVS     R0,#+15
   \   0000001E   ........           BL       FLASH_WaitForLastOperation
    387          
    388              if(status != FLASH_BUSY)
   \   00000022   0128               CMP      R0,#+1
   \   00000024   04D0               BEQ.N    ??FLASH_ProgramHalfWord_0
    389              {
    390                /* if the program operation is completed, disable the PG Bit */
    391                FLASH->CR &= CR_PG_Reset;
   \   00000026   2968               LDR      R1,[R5, #+0]
   \   00000028   41F6FE72           MOVW     R2,#+8190
   \   0000002C   1140               ANDS     R1,R2,R1
   \   0000002E   2960               STR      R1,[R5, #+0]
    392              }
    393            } 
    394            /* Return the Program Status */
    395            return status;
   \                     ??FLASH_ProgramHalfWord_0:
   \   00000030   70BD               POP      {R4-R6,PC}       ;; return
    396          }
    397          
    398          /*******************************************************************************
    399          * Function Name  : FLASH_ProgramOptionByteData
    400          * Description    : Programs a half word at a specified Option Byte Data address.
    401          * Input          : - Address: specifies the address to be programmed.
    402          *                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    403          *                  - Data: specifies the data to be programmed.
    404          * Output         : None
    405          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    406          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    407          *                  FLASH_TIMEOUT. 
    408          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    409          FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)  //@"FastProcRAM"
    410          {
   \                     FLASH_ProgramOptionByteData:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    411            FLASH_Status status = FLASH_COMPLETE;
    412          
    413            /* Check the parameters */
    414            assert_param(IS_OB_DATA_ADDRESS(Address));
    415          
    416            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000006   0F20               MOVS     R0,#+15
   \   00000008   ........           BL       FLASH_WaitForLastOperation
    417          
    418            if(status == FLASH_COMPLETE)
   \   0000000C   0428               CMP      R0,#+4
   \   0000000E   16D1               BNE.N    ??FLASH_ProgramOptionByteData_0
    419            {
    420              /* Authorize the small information block programming */
    421              FLASH->OPTKEYR = FLASH_KEY1;
   \   00000010   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   00000012   ....               LDR.N    R1,??DataTable42  ;; 0x45670123
   \   00000014   0160               STR      R1,[R0, #+0]
    422              FLASH->OPTKEYR = FLASH_KEY2;
   \   00000016   ....               LDR.N    R1,??DataTable43  ;; 0xcdef89ab
   \   00000018   0160               STR      R1,[R0, #+0]
    423          
    424              /* Enables the Option Bytes Programming operation */
    425              FLASH->CR |= CR_OPTPG_Set; 
   \   0000001A   8068               LDR      R0,[R0, #+8]
   \   0000001C   40F01000           ORR      R0,R0,#0x10
   \   00000020   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000022   8860               STR      R0,[R1, #+8]
    426              *(vu16*)Address = Data;
   \   00000024   2C80               STRH     R4,[R5, #+0]
    427              
    428              /* Wait for last operation to be completed */
    429              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000026   0F20               MOVS     R0,#+15
   \   00000028   ........           BL       FLASH_WaitForLastOperation
    430          
    431              if(status != FLASH_BUSY)
   \   0000002C   0128               CMP      R0,#+1
   \   0000002E   06D0               BEQ.N    ??FLASH_ProgramOptionByteData_0
    432              {
    433                /* if the program operation is completed, disable the OPTPG Bit */
    434                FLASH->CR &= CR_OPTPG_Reset;
   \   00000030   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000032   8968               LDR      R1,[R1, #+8]
   \   00000034   41F6EF72           MOVW     R2,#+8175
   \   00000038   1140               ANDS     R1,R2,R1
   \   0000003A   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   0000003C   9160               STR      R1,[R2, #+8]
    435              }
    436            }    
    437            /* Return the Option Byte Data Program Status */
    438            return status;      
   \                     ??FLASH_ProgramOptionByteData_0:
   \   0000003E   32BD               POP      {R1,R4,R5,PC}    ;; return
    439          }
    440          
    441          /*******************************************************************************
    442          * Function Name  : FLASH_EnableWriteProtection
    443          * Description    : Write protects the desired pages
    444          * Input          : - FLASH_Pages: specifies the address of the pages to be 
    445          *                    write protected. This parameter can be:
    446          *                    - For STM32F10Xxx Medium-density devices (FLASH page size equal to 1 KB)
    447          *                       - A value between FLASH_WRProt_Pages0to3 and 
    448          *                         FLASH_WRProt_Pages124to127
    449          *                    - For STM32F10Xxx High-density devices (FLASH page size equal to 2 KB) 
    450          *                       - A value between FLASH_WRProt_Pages0to1 and
    451          *                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255 
    452          *                       - FLASH_WRProt_AllPages
    453          * Output         : None
    454          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    455          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    456          *                  FLASH_TIMEOUT.
    457          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    458          FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)  //@"FastProcRAM"
    459          {
   \                     FLASH_EnableWriteProtection:
   \   00000000   F8B5               PUSH     {R3-R7,LR}
    460            u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
    461            
    462            FLASH_Status status = FLASH_COMPLETE;
    463            
    464            /* Check the parameters */
    465            assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    466            
    467            FLASH_Pages = (u32)(~FLASH_Pages);
   \   00000002   C043               MVNS     R0,R0
    468            WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
   \   00000004   C4B2               UXTB     R4,R0
    469            WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
   \   00000006   00F47F41           AND      R1,R0,#0xFF00
   \   0000000A   0D0A               LSRS     R5,R1,#+8
    470            WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
   \   0000000C   00F47F01           AND      R1,R0,#0xFF0000
   \   00000010   0E0C               LSRS     R6,R1,#+16
    471            WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
   \   00000012   070E               LSRS     R7,R0,#+24
    472            
    473            /* Wait for last operation to be completed */
    474            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000014   0F20               MOVS     R0,#+15
   \   00000016   ........           BL       FLASH_WaitForLastOperation
    475            
    476            if(status == FLASH_COMPLETE)
   \   0000001A   0428               CMP      R0,#+4
   \   0000001C   34D1               BNE.N    ??FLASH_EnableWriteProtection_0
    477            {
    478              /* Authorizes the small information block programming */
    479              FLASH->OPTKEYR = FLASH_KEY1;
   \   0000001E   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000020   ....               LDR.N    R2,??DataTable42  ;; 0x45670123
   \   00000022   0A60               STR      R2,[R1, #+0]
    480              FLASH->OPTKEYR = FLASH_KEY2;
   \   00000024   ....               LDR.N    R2,??DataTable43  ;; 0xcdef89ab
   \   00000026   0A60               STR      R2,[R1, #+0]
    481              FLASH->CR |= CR_OPTPG_Set;
   \   00000028   8968               LDR      R1,[R1, #+8]
   \   0000002A   41F01001           ORR      R1,R1,#0x10
   \   0000002E   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   00000030   9160               STR      R1,[R2, #+8]
    482          
    483              if(WRP0_Data != 0xFF)
   \   00000032   FF2C               CMP      R4,#+255
   \   00000034   06D0               BEQ.N    ??FLASH_EnableWriteProtection_1
    484              {
    485                OB->WRP0 = WRP0_Data;
   \   00000036   1548               LDR.N    R0,??FLASH_EnableWriteProtection_2  ;; 0x1ffff808
   \   00000038   0480               STRH     R4,[R0, #+0]
    486                
    487                /* Wait for last operation to be completed */
    488                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000003A   0F20               MOVS     R0,#+15
   \   0000003C   ........           BL       FLASH_WaitForLastOperation
    489              }
    490              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
   \   00000040   0428               CMP      R0,#+4
   \   00000042   06D1               BNE.N    ??FLASH_EnableWriteProtection_3
   \                     ??FLASH_EnableWriteProtection_1:
   \   00000044   FF2D               CMP      R5,#+255
   \   00000046   06D0               BEQ.N    ??FLASH_EnableWriteProtection_4
    491              {
    492                OB->WRP1 = WRP1_Data;
   \   00000048   1048               LDR.N    R0,??FLASH_EnableWriteProtection_2  ;; 0x1ffff808
   \   0000004A   4580               STRH     R5,[R0, #+2]
    493                
    494                /* Wait for last operation to be completed */
    495                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000004C   0F20               MOVS     R0,#+15
   \   0000004E   ........           BL       FLASH_WaitForLastOperation
    496              }
    497          
    498              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_3:
   \   00000052   0428               CMP      R0,#+4
   \   00000054   06D1               BNE.N    ??FLASH_EnableWriteProtection_5
   \                     ??FLASH_EnableWriteProtection_4:
   \   00000056   FF2E               CMP      R6,#+255
   \   00000058   06D0               BEQ.N    ??FLASH_EnableWriteProtection_6
    499              {
    500                OB->WRP2 = WRP2_Data;
   \   0000005A   0C48               LDR.N    R0,??FLASH_EnableWriteProtection_2  ;; 0x1ffff808
   \   0000005C   8680               STRH     R6,[R0, #+4]
    501                
    502                /* Wait for last operation to be completed */
    503                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   0000005E   0F20               MOVS     R0,#+15
   \   00000060   ........           BL       FLASH_WaitForLastOperation
    504              }
    505              
    506              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
   \                     ??FLASH_EnableWriteProtection_5:
   \   00000064   0428               CMP      R0,#+4
   \   00000066   06D1               BNE.N    ??FLASH_EnableWriteProtection_7
   \                     ??FLASH_EnableWriteProtection_6:
   \   00000068   FF2F               CMP      R7,#+255
   \   0000006A   06D0               BEQ.N    ??FLASH_EnableWriteProtection_8
    507              {
    508                OB->WRP3 = WRP3_Data;
   \   0000006C   0748               LDR.N    R0,??FLASH_EnableWriteProtection_2  ;; 0x1ffff808
   \   0000006E   C780               STRH     R7,[R0, #+6]
    509               
    510                /* Wait for last operation to be completed */
    511                status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000070   0F20               MOVS     R0,#+15
   \   00000072   ........           BL       FLASH_WaitForLastOperation
    512              }
    513                    
    514              if(status != FLASH_BUSY)
   \                     ??FLASH_EnableWriteProtection_7:
   \   00000076   0128               CMP      R0,#+1
   \   00000078   06D0               BEQ.N    ??FLASH_EnableWriteProtection_0
    515              {
    516                /* if the program operation is completed, disable the OPTPG Bit */
    517                FLASH->CR &= CR_OPTPG_Reset;
   \                     ??FLASH_EnableWriteProtection_8:
   \   0000007A   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   0000007C   8968               LDR      R1,[R1, #+8]
   \   0000007E   41F6EF72           MOVW     R2,#+8175
   \   00000082   1140               ANDS     R1,R2,R1
   \   00000084   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   00000086   9160               STR      R1,[R2, #+8]
    518              }
    519            } 
    520            /* Return the write protection operation Status */
    521            return status;       
   \                     ??FLASH_EnableWriteProtection_0:
   \   00000088   F2BD               POP      {R1,R4-R7,PC}    ;; return
   \   0000008A   00BF               Nop      
   \                     ??FLASH_EnableWriteProtection_2:
   \   0000008C   08F8FF1F           DC32     0x1ffff808
    522          }
    523          
    524          /*******************************************************************************
    525          * Function Name  : FLASH_ReadOutProtection
    526          * Description    : Enables or disables the read out protection.
    527          *                  If the user has already programmed the other option bytes before 
    528          *                  calling this function, he must re-program them since this 
    529          *                  function erases all option bytes.
    530          * Input          : - Newstate: new state of the ReadOut Protection.
    531          *                    This parameter can be: ENABLE or DISABLE.
    532          * Output         : None
    533          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    534          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    535          *                  FLASH_TIMEOUT.
    536          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    537          FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)  //@"FastProcRAM"
    538          {
   \                     FLASH_ReadOutProtection:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
    539            FLASH_Status status = FLASH_COMPLETE;
    540          
    541            /* Check the parameters */
    542            assert_param(IS_FUNCTIONAL_STATE(NewState));
    543          
    544            status = FLASH_WaitForLastOperation(EraseTimeout);
   \   00000004   40F6FF75           MOVW     R5,#+4095
   \   00000008   2800               MOVS     R0,R5
   \   0000000A   ........           BL       FLASH_WaitForLastOperation
    545          
    546            if(status == FLASH_COMPLETE)
   \   0000000E   0428               CMP      R0,#+4
   \   00000010   36D1               BNE.N    ??FLASH_ReadOutProtection_0
    547            {
    548              /* Authorizes the small information block programming */
    549              FLASH->OPTKEYR = FLASH_KEY1;
   \   00000012   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   00000014   ....               LDR.N    R1,??DataTable42  ;; 0x45670123
   \   00000016   0160               STR      R1,[R0, #+0]
    550              FLASH->OPTKEYR = FLASH_KEY2;
   \   00000018   ....               LDR.N    R1,??DataTable43  ;; 0xcdef89ab
   \   0000001A   0160               STR      R1,[R0, #+0]
    551          
    552              FLASH->CR |= CR_OPTER_Set;
   \   0000001C   8068               LDR      R0,[R0, #+8]
   \   0000001E   40F02000           ORR      R0,R0,#0x20
   \   00000022   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000024   8860               STR      R0,[R1, #+8]
    553              FLASH->CR |= CR_STRT_Set;
   \   00000026   8868               LDR      R0,[R1, #+8]
   \   00000028   40F04000           ORR      R0,R0,#0x40
   \   0000002C   8860               STR      R0,[R1, #+8]
    554          
    555              /* Wait for last operation to be completed */
    556              status = FLASH_WaitForLastOperation(EraseTimeout);
   \   0000002E   2800               MOVS     R0,R5
   \   00000030   ........           BL       FLASH_WaitForLastOperation
    557          
    558              if(status == FLASH_COMPLETE)
   \   00000034   41F6DF71           MOVW     R1,#+8159
   \   00000038   0428               CMP      R0,#+4
   \   0000003A   1AD1               BNE.N    ??FLASH_ReadOutProtection_1
    559              {
    560                /* if the erase operation is completed, disable the OPTER Bit */
    561                FLASH->CR &= CR_OPTER_Reset;
   \   0000003C   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   0000003E   8068               LDR      R0,[R0, #+8]
   \   00000040   0840               ANDS     R0,R1,R0
   \   00000042   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000044   8860               STR      R0,[R1, #+8]
    562          
    563                /* Enable the Option Bytes Programming operation */
    564                FLASH->CR |= CR_OPTPG_Set; 
   \   00000046   8868               LDR      R0,[R1, #+8]
   \   00000048   40F01000           ORR      R0,R0,#0x10
   \   0000004C   8860               STR      R0,[R1, #+8]
    565          
    566                if(NewState != DISABLE)
   \   0000004E   ....               LDR.N    R0,??DataTable36  ;; 0x1ffff800
   \   00000050   0CB1               CBZ      R4,??FLASH_ReadOutProtection_2
    567                {
    568                  OB->RDP = 0x00;
   \   00000052   0021               MOVS     R1,#+0
   \   00000054   00E0               B.N      ??FLASH_ReadOutProtection_3
    569                }
    570                else
    571                {
    572                  OB->RDP = RDP_Key;  
   \                     ??FLASH_ReadOutProtection_2:
   \   00000056   A521               MOVS     R1,#+165
   \                     ??FLASH_ReadOutProtection_3:
   \   00000058   0180               STRH     R1,[R0, #+0]
    573                }
    574          
    575                /* Wait for last operation to be completed */
    576                status = FLASH_WaitForLastOperation(EraseTimeout); 
   \   0000005A   2800               MOVS     R0,R5
   \   0000005C   ........           BL       FLASH_WaitForLastOperation
    577              
    578                if(status != FLASH_BUSY)
   \   00000060   0128               CMP      R0,#+1
   \   00000062   0DD0               BEQ.N    ??FLASH_ReadOutProtection_0
    579                {
    580                  /* if the program operation is completed, disable the OPTPG Bit */
    581                  FLASH->CR &= CR_OPTPG_Reset;
   \   00000064   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000066   8968               LDR      R1,[R1, #+8]
   \   00000068   41F6EF72           MOVW     R2,#+8175
   \   0000006C   1140               ANDS     R1,R2,R1
   \   0000006E   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   00000070   05E0               B.N      ??FLASH_ReadOutProtection_4
    582                }
    583              }
    584              else 
    585              {
    586                if(status != FLASH_BUSY)
   \                     ??FLASH_ReadOutProtection_1:
   \   00000072   0128               CMP      R0,#+1
   \   00000074   04D0               BEQ.N    ??FLASH_ReadOutProtection_0
    587                {
    588                  /* Disable the OPTER Bit */
    589                  FLASH->CR &= CR_OPTER_Reset;
   \   00000076   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   00000078   9268               LDR      R2,[R2, #+8]
   \   0000007A   1140               ANDS     R1,R1,R2
   \   0000007C   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \                     ??FLASH_ReadOutProtection_4:
   \   0000007E   9160               STR      R1,[R2, #+8]
    590                }
    591              }
    592            }
    593            /* Return the protection operation Status */
    594            return status;      
   \                     ??FLASH_ReadOutProtection_0:
   \   00000080   32BD               POP      {R1,R4,R5,PC}    ;; return
    595          }
    596            	
    597          /*******************************************************************************
    598          * Function Name  : FLASH_UserOptionByteConfig
    599          * Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
    600          *                  RST_STDBY.
    601          * Input          : - OB_IWDG: Selects the IWDG mode
    602          *                     This parameter can be one of the following values:
    603          *                     - OB_IWDG_SW: Software IWDG selected
    604          *                     - OB_IWDG_HW: Hardware IWDG selected
    605          *                  - OB_STOP: Reset event when entering STOP mode.
    606          *                     This parameter can be one of the following values:
    607          *                     - OB_STOP_NoRST: No reset generated when entering in STOP
    608          *                     - OB_STOP_RST: Reset generated when entering in STOP
    609          *                  - OB_STDBY: Reset event when entering Standby mode.
    610          *                    This parameter can be one of the following values:
    611          *                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
    612          *                     - OB_STDBY_RST: Reset generated when entering in STANDBY
    613          * Output         : None
    614          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    615          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    616          *                  FLASH_TIMEOUT.
    617          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    618          FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)  //@"FastProcRAM"
    619          {
   \                     FLASH_UserOptionByteConfig:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1500               MOVS     R5,R2
    620            FLASH_Status status = FLASH_COMPLETE; 
    621          
    622            /* Check the parameters */
    623            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    624            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    625            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    626          
    627            /* Authorize the small information block programming */
    628            FLASH->OPTKEYR = FLASH_KEY1;
   \   00000008   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   0000000A   ....               LDR.N    R1,??DataTable42  ;; 0x45670123
   \   0000000C   0160               STR      R1,[R0, #+0]
    629            FLASH->OPTKEYR = FLASH_KEY2;
   \   0000000E   ....               LDR.N    R1,??DataTable43  ;; 0xcdef89ab
   \   00000010   0160               STR      R1,[R0, #+0]
    630            
    631            /* Wait for last operation to be completed */
    632            status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000012   0F20               MOVS     R0,#+15
   \   00000014   ........           BL       FLASH_WaitForLastOperation
    633            
    634            if(status == FLASH_COMPLETE)
   \   00000018   0428               CMP      R0,#+4
   \   0000001A   18D1               BNE.N    ??FLASH_UserOptionByteConfig_0
    635            {  
    636              /* Enable the Option Bytes Programming operation */
    637              FLASH->CR |= CR_OPTPG_Set; 
   \   0000001C   ....               LDR.N    R0,??DataTable47  ;; 0x40022008
   \   0000001E   8068               LDR      R0,[R0, #+8]
   \   00000020   40F01000           ORR      R0,R0,#0x10
   \   00000024   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000026   8860               STR      R0,[R1, #+8]
    638                     
    639              OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
   \   00000028   44EA0600           ORR      R0,R4,R6
   \   0000002C   2843               ORRS     R0,R5,R0
   \   0000002E   40F0F800           ORR      R0,R0,#0xF8
   \   00000032   0749               LDR.N    R1,??FLASH_UserOptionByteConfig_1  ;; 0x1ffff802
   \   00000034   0880               STRH     R0,[R1, #+0]
    640            
    641              /* Wait for last operation to be completed */
    642              status = FLASH_WaitForLastOperation(ProgramTimeout);
   \   00000036   0F20               MOVS     R0,#+15
   \   00000038   ........           BL       FLASH_WaitForLastOperation
    643          
    644              if(status != FLASH_BUSY)
   \   0000003C   0128               CMP      R0,#+1
   \   0000003E   06D0               BEQ.N    ??FLASH_UserOptionByteConfig_0
    645              {
    646                /* if the program operation is completed, disable the OPTPG Bit */
    647                FLASH->CR &= CR_OPTPG_Reset;
   \   00000040   ....               LDR.N    R1,??DataTable47  ;; 0x40022008
   \   00000042   8968               LDR      R1,[R1, #+8]
   \   00000044   41F6EF72           MOVW     R2,#+8175
   \   00000048   1140               ANDS     R1,R2,R1
   \   0000004A   ....               LDR.N    R2,??DataTable47  ;; 0x40022008
   \   0000004C   9160               STR      R1,[R2, #+8]
    648              }
    649            }    
    650            /* Return the Option Byte program Status */
    651            return status;
   \                     ??FLASH_UserOptionByteConfig_0:
   \   0000004E   70BD               POP      {R4-R6,PC}       ;; return
   \                     ??FLASH_UserOptionByteConfig_1:
   \   00000050   02F8FF1F           DC32     0x1ffff802
    652          }
    653          
    654          /*******************************************************************************
    655          * Function Name  : FLASH_GetUserOptionByte
    656          * Description    : Returns the FLASH User Option Bytes values.
    657          * Input          : None
    658          * Output         : None
    659          * Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
    660          *                  and RST_STDBY(Bit2).
    661          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    662          u32 FLASH_GetUserOptionByte(void)  //@"FastProcRAM"
    663          {
    664            /* Return the User Option Byte */
    665            return (u32)(FLASH->OBR >> 2);
   \                     FLASH_GetUserOptionByte:
   \   00000000   ....               LDR.N    R0,??DataTable49  ;; 0x4002201c
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   8008               LSRS     R0,R0,#+2
   \   00000006   7047               BX       LR               ;; return
    666          }
    667          
    668          /*******************************************************************************
    669          * Function Name  : FLASH_GetWriteProtectionOptionByte
    670          * Description    : Returns the FLASH Write Protection Option Bytes Register value.
    671          * Input          : None
    672          * Output         : None
    673          * Return         : The FLASH Write Protection  Option Bytes Register value
    674          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    675          u32 FLASH_GetWriteProtectionOptionByte(void)  //@"FastProcRAM"
    676          {
    677            /* Return the Falsh write protection Register value */
    678            return (u32)(FLASH->WRPR);
   \                     FLASH_GetWriteProtectionOptionByte:
   \   00000000   0148               LDR.N    R0,??FLASH_GetWriteProtectionOptionByte_0  ;; 0x40022020
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
   \   00000006   00BF               Nop      
   \                     ??FLASH_GetWriteProtectionOptionByte_0:
   \   00000008   20200240           DC32     0x40022020
    679          }
    680          
    681          /*******************************************************************************
    682          * Function Name  : FLASH_GetReadOutProtectionStatus
    683          * Description    : Checks whether the FLASH Read Out Protection Status is set 
    684          *                  or not.
    685          * Input          : None
    686          * Output         : None
    687          * Return         : FLASH ReadOut Protection Status(SET or RESET)
    688          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    689          FlagStatus FLASH_GetReadOutProtectionStatus(void)  //@"FastProcRAM"
    690          {
    691            FlagStatus readoutstatus = RESET;
    692          
    693            if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
   \                     FLASH_GetReadOutProtectionStatus:
   \   00000000   ....               LDR.N    R0,??DataTable49  ;; 0x4002201c
   \   00000002   0068               LDR      R0,[R0, #+0]
    694            {
    695              readoutstatus = SET;
    696            }
    697            else
    698            {
    699              readoutstatus = RESET;
   \   00000004   10F00200           ANDS     R0,R0,#0x2
   \   00000008   18BF               IT       NE 
   \   0000000A   0120               MOVNE    R0,#+1
    700            }
    701            return readoutstatus;
   \   0000000C   7047               BX       LR               ;; return
    702          }
    703          
    704          /*******************************************************************************
    705          * Function Name  : FLASH_GetPrefetchBufferStatus
    706          * Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
    707          * Input          : None
    708          * Output         : None
    709          * Return         : FLASH Prefetch Buffer Status (SET or RESET).
    710          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    711          FlagStatus FLASH_GetPrefetchBufferStatus(void)  //@"FastProcRAM"
    712          {
    713            FlagStatus bitstatus = RESET;
    714            
    715            if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
   \                     FLASH_GetPrefetchBufferStatus:
   \   00000000   0348               LDR.N    R0,??FLASH_GetPrefetchBufferStatus_0  ;; 0x40022000
   \   00000002   0068               LDR      R0,[R0, #+0]
    716            {
    717              bitstatus = SET;
    718            }
    719            else
    720            {
    721              bitstatus = RESET;
   \   00000004   10F02000           ANDS     R0,R0,#0x20
   \   00000008   18BF               IT       NE 
   \   0000000A   0120               MOVNE    R0,#+1
    722            }
    723            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
    724            return bitstatus; 
   \   0000000C   7047               BX       LR               ;; return
   \   0000000E   00BF               Nop      
   \                     ??FLASH_GetPrefetchBufferStatus_0:
   \   00000010   00200240           DC32     0x40022000
    725          }
    726          
    727          /*******************************************************************************
    728          * Function Name  : FLASH_ITConfig
    729          * Description    : Enables or disables the specified FLASH interrupts.
    730          * Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
    731          *                    enabled or disabled.
    732          *                    This parameter can be any combination of the following values:
    733          *                       - FLASH_IT_ERROR: FLASH Error Interrupt
    734          *                       - FLASH_IT_EOP: FLASH end of operation Interrupt
    735          * Output         : None
    736          * Return         : None 
    737          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    738          void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)  //@"FastProcRAM"
    739          {
    740            /* Check the parameters */
    741            assert_param(IS_FLASH_IT(FLASH_IT)); 
    742            assert_param(IS_FUNCTIONAL_STATE(NewState));
    743          
    744            if(NewState != DISABLE)
   \                     FLASH_ITConfig:
   \   00000000   ....               LDR.N    R2,??DataTable50  ;; 0x40022010
   \   00000002   0029               CMP      R1,#+0
   \   00000004   1168               LDR      R1,[R2, #+0]
   \   00000006   01D0               BEQ.N    ??FLASH_ITConfig_0
    745            {
    746              /* Enable the interrupt sources */
    747              FLASH->CR |= FLASH_IT;
   \   00000008   0843               ORRS     R0,R0,R1
   \   0000000A   01E0               B.N      ??FLASH_ITConfig_1
    748            }
    749            else
    750            {
    751              /* Disable the interrupt sources */
    752              FLASH->CR &= ~(u32)FLASH_IT;
   \                     ??FLASH_ITConfig_0:
   \   0000000C   C043               MVNS     R0,R0
   \   0000000E   0840               ANDS     R0,R0,R1
   \                     ??FLASH_ITConfig_1:
   \   00000010   1060               STR      R0,[R2, #+0]
    753            }
    754          }
   \   00000012   7047               BX       LR               ;; return
    755          
    756          /*******************************************************************************
    757          * Function Name  : FLASH_GetFlagStatus
    758          * Description    : Checks whether the specified FLASH flag is set or not.
    759          * Input          : - FLASH_FLAG: specifies the FLASH flag to check.
    760          *                     This parameter can be one of the following values:
    761          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    762          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    763          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    764          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    765          *                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
    766          * Output         : None
    767          * Return         : The new state of FLASH_FLAG (SET or RESET).
    768          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    769          FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)  //@"FastProcRAM"
    770          {
    771            FlagStatus bitstatus = RESET;
    772          
    773            /* Check the parameters */
    774            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
    775          
    776            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
   \                     FLASH_GetFlagStatus:
   \   00000000   0128               CMP      R0,#+1
   \   00000002   04D1               BNE.N    ??FLASH_GetFlagStatus_0
    777            {
    778              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
   \   00000004   ....               LDR.N    R0,??DataTable54  ;; 0x4002200c
   \   00000006   0069               LDR      R0,[R0, #+16]
    779              {
    780                bitstatus = SET;
    781              }
    782              else
    783              {
    784                bitstatus = RESET;
   \   00000008   00F00100           AND      R0,R0,#0x1
   \   0000000C   05E0               B.N      ??FLASH_GetFlagStatus_1
    785              }
    786            }
    787            else
    788            {
    789             if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
   \                     ??FLASH_GetFlagStatus_0:
   \   0000000E   ....               LDR.N    R1,??DataTable54  ;; 0x4002200c
   \   00000010   0968               LDR      R1,[R1, #+0]
   \   00000012   0140               ANDS     R1,R0,R1
   \   00000014   0800               MOVS     R0,R1
   \   00000016   18BF               IT       NE 
   \   00000018   0120               MOVNE    R0,#+1
    790              {
    791                bitstatus = SET;
    792              }
    793              else
    794              {
    795                bitstatus = RESET;
    796              }
    797            }
    798            /* Return the new state of FLASH_FLAG (SET or RESET) */
    799            return bitstatus;
   \                     ??FLASH_GetFlagStatus_1:
   \   0000001A   40B2               SXTB     R0,R0
   \   0000001C   7047               BX       LR               ;; return
    800          }
    801          
    802          /*******************************************************************************
    803          * Function Name  : FLASH_ClearFlag
    804          * Description    : Clears the FLASHs pending flags.
    805          * Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
    806          *                    This parameter can be any combination of the following values:
    807          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    808          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    809          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    810          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    811          * Output         : None
    812          * Return         : None
    813          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    814          void FLASH_ClearFlag(u16 FLASH_FLAG)  //@"FastProcRAM"
    815          {
    816            /* Check the parameters */
    817            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
    818            
    819            /* Clear the flags */
    820            FLASH->SR = FLASH_FLAG;
   \                     FLASH_ClearFlag:
   \   00000000   ....               LDR.N    R1,??DataTable54  ;; 0x4002200c
   \   00000002   0860               STR      R0,[R1, #+0]
    821          }
   \   00000004   7047               BX       LR               ;; return
    822          
    823          /*******************************************************************************
    824          * Function Name  : FLASH_GetStatus
    825          * Description    : Returns the FLASH Status.
    826          * Input          : None
    827          * Output         : None
    828          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    829          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP or FLASH_COMPLETE
    830          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    831          FLASH_Status FLASH_GetStatus(void)  //@"FastProcRAM"
    832          {
    833            FLASH_Status flashstatus = FLASH_COMPLETE;
    834            
    835            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \                     FLASH_GetStatus:
   \   00000000   ....               LDR.N    R0,??DataTable54  ;; 0x4002200c
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   11F0010F           TST      R1,#0x1
   \   00000008   01D0               BEQ.N    ??FLASH_GetStatus_0
    836            {
    837              flashstatus = FLASH_BUSY;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   7047               BX       LR
    838            }
    839            else 
    840            {  
    841              if(FLASH->SR & FLASH_FLAG_PGERR)
   \                     ??FLASH_GetStatus_0:
   \   0000000E   0168               LDR      R1,[R0, #+0]
   \   00000010   11F0040F           TST      R1,#0x4
   \   00000014   01D0               BEQ.N    ??FLASH_GetStatus_1
    842              { 
    843                flashstatus = FLASH_ERROR_PG;
   \   00000016   0220               MOVS     R0,#+2
   \   00000018   7047               BX       LR
    844              }
    845              else 
    846              {
    847                if(FLASH->SR & FLASH_FLAG_WRPRTERR)
   \                     ??FLASH_GetStatus_1:
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   10F0100F           TST      R0,#0x10
   \   00000020   01D0               BEQ.N    ??FLASH_GetStatus_2
    848                {
    849                  flashstatus = FLASH_ERROR_WRP;
   \   00000022   0320               MOVS     R0,#+3
   \   00000024   7047               BX       LR
    850                }
    851                else
    852                {
    853                  flashstatus = FLASH_COMPLETE;
   \                     ??FLASH_GetStatus_2:
   \   00000026   0420               MOVS     R0,#+4
    854                }
    855              }
    856            }
    857            /* Return the Flash Status */
    858            return flashstatus;
   \                     ??FLASH_GetStatus_3:
   \   00000028   7047               BX       LR               ;; return
    859          }
    860          
    861          /*******************************************************************************
    862          * Function Name  : FLASH_WaitForLastOperation
    863          * Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
    864          * Input          : - Timeout: FLASH progamming Timeout
    865          * Output         : None
    866          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    867          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    868          *                  FLASH_TIMEOUT.
    869          *******************************************************************************/

   \                                 In section FastProcRAM, align 4, keep-with-next
    870          FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)  //@"FastProcRAM"
    871          { 
   \                     FLASH_WaitForLastOperation:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    872            FLASH_Status status = FLASH_COMPLETE;
    873             
    874            /* Check for the Flash Status */
    875            status = FLASH_GetStatus();
   \   00000006   ........           BL       FLASH_GetStatus
   \   0000000A   08E0               B.N      ??FLASH_WaitForLastOperation_0
    876          
    877            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
    878            while((status == FLASH_BUSY) && (Timeout != 0x00))
    879            {
   \                     ??FLASH_WaitForLastOperation_1:
   \   0000000C   0098               LDR      R0,[SP, #+0]
   \   0000000E   401E               SUBS     R0,R0,#+1
   \                     ??FLASH_WaitForLastOperation_2:
   \   00000010   0090               STR      R0,[SP, #+0]
   \   00000012   0098               LDR      R0,[SP, #+0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   F9D1               BNE.N    ??FLASH_WaitForLastOperation_1
    880              delay();
    881              status = FLASH_GetStatus();
   \   00000018   ........           BL       FLASH_GetStatus
    882              Timeout--;
   \   0000001C   641E               SUBS     R4,R4,#+1
   \                     ??FLASH_WaitForLastOperation_0:
   \   0000001E   0128               CMP      R0,#+1
   \   00000020   04D1               BNE.N    ??FLASH_WaitForLastOperation_3
   \   00000022   24B1               CBZ      R4,??FLASH_WaitForLastOperation_4
   \   00000024   0020               MOVS     R0,#+0
   \   00000026   0090               STR      R0,[SP, #+0]
   \   00000028   FF20               MOVS     R0,#+255
   \   0000002A   F1E7               B.N      ??FLASH_WaitForLastOperation_2
    883            }
    884          
    885            if(Timeout == 0x00 )
   \                     ??FLASH_WaitForLastOperation_3:
   \   0000002C   04B9               CBNZ     R4,??FLASH_WaitForLastOperation_5
    886            {
    887              status = FLASH_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_4:
   \   0000002E   0520               MOVS     R0,#+5
    888            }
    889          
    890            /* Return the operation status */
    891            return status;
   \                     ??FLASH_WaitForLastOperation_5:
   \   00000030   16BD               POP      {R1,R2,R4,PC}    ;; return
    892          }

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   00200240           DC32     0x40022000

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   00F8FF1F           DC32     0x1ffff800

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   23016745           DC32     0x45670123

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   AB89EFCD           DC32     0xcdef89ab

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable47:
   \   00000000   08200240           DC32     0x40022008

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable49:
   \   00000000   1C200240           DC32     0x4002201c

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   10200240           DC32     0x40022010

   \                                 In section FastProcRAM, align 4, keep-with-next
   \                     ??DataTable54:
   \   00000000   0C200240           DC32     0x4002200c
    893          
    894          /*******************************************************************************
    895          * Function Name  : delay
    896          * Description    : Inserts a time delay.
    897          * Input          : None
    898          * Output         : None
    899          * Return         : None
    900          *******************************************************************************/
    901          static void delay(void)  //@"FastProcRAM"
    902          {
    903            vu32 i = 0;
    904          
    905            for(i = 0xFF; i != 0; i--)
    906            {
    907            }
    908          }
    909          #endif
    910          
    911          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     FLASH_ClearFlag                     0
     FLASH_EnableWriteProtection         0
     FLASH_EraseAllPages                 0
     FLASH_EraseOptionBytes              0
     FLASH_ErasePage                     0
     FLASH_GetFlagStatus                 0
     FLASH_GetPrefetchBufferStatus       0
     FLASH_GetReadOutProtectionStatus
                                         0
     FLASH_GetStatus                     0
     FLASH_GetUserOptionByte             0
     FLASH_GetWriteProtectionOptionByte
                                         0
     FLASH_HalfCycleAccessCmd            0
     FLASH_ITConfig                      0
     FLASH_Lock                          0
     FLASH_PrefetchBufferCmd             0
     FLASH_ProgramHalfWord               0
     FLASH_ProgramOptionByteData         0
     FLASH_ProgramWord                   0
     FLASH_ReadOutProtection             0
     FLASH_SetLatency                    0
     FLASH_Unlock                        0
     FLASH_UserOptionByteConfig          0
     FLASH_WaitForLastOperation          0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     FLASH_SetLatency                 10
     ??Subroutine1_0                  10
     FLASH_HalfCycleAccessCmd          8
     ?Subroutine0                      4
     FLASH_PrefetchBufferCmd           8
     FLASH_Unlock                     24
     FLASH_Lock                       16
     FLASH_ErasePage                  62
     FLASH_EraseAllPages              56
     FLASH_EraseOptionBytes          122
     FLASH_ProgramWord                64
     FLASH_ProgramHalfWord            50
     FLASH_ProgramOptionByteData      64
     FLASH_EnableWriteProtection     144
     FLASH_ReadOutProtection         130
     FLASH_UserOptionByteConfig       84
     FLASH_GetUserOptionByte           8
     FLASH_GetWriteProtectionOptionByte
                                      12
     FLASH_GetReadOutProtectionStatus
                                      14
     FLASH_GetPrefetchBufferStatus    20
     FLASH_ITConfig                   20
     FLASH_GetFlagStatus              30
     FLASH_ClearFlag                   6
     FLASH_GetStatus                  42
     FLASH_WaitForLastOperation       50
     ??DataTable2                      4
     ??DataTable36                     4
     ??DataTable42                     4
     ??DataTable43                     4
     ??DataTable47                     4
     ??DataTable49                     4
     ??DataTable50                     4
     ??DataTable54                     4

 
 1 090 bytes in section FastProcRAM
 
 1 090 bytes of CODE memory

Errors: none
Warnings: none
