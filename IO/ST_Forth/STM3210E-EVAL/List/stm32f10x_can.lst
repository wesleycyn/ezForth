###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.20.0.50892/W32 for ARM     07/Oct/2009  13:03:54 #
# Copyright 1999-2008 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f #
#                    10x_can.c                                                #
#    Command line =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f #
#                    10x_can.c -D VECT_TAB_FLASH -lC                          #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\List #
#                    \ -o F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL #
#                    \Obj\ --debug --endian=little --cpu=Cortex-M3 -e         #
#                    --char_is_signed --require_prototypes --fpu=None         #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.0\ARM\INC\DLib_Config_Full.h" -I             #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\ -I                #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\inc\ -I    #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.0\ARM\INC\" -Ohz                                       #
#    List file    =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\List #
#                    \stm32f10x_can.lst                                       #
#    Object file  =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\Obj\ #
#                    stm32f10x_can.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f10x_can.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_can.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the CAN firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_can.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          
     22          /* Private define ------------------------------------------------------------*/
     23          /* CAN Master Control Register bits */
     24          #define MCR_INRQ     ((u32)0x00000001) /* Initialization request */
     25          #define MCR_SLEEP    ((u32)0x00000002) /* Sleep mode request */
     26          #define MCR_TXFP     ((u32)0x00000004) /* Transmit FIFO priority */
     27          #define MCR_RFLM     ((u32)0x00000008) /* Receive FIFO locked mode */
     28          #define MCR_NART     ((u32)0x00000010) /* No automatic retransmission */
     29          #define MCR_AWUM     ((u32)0x00000020) /* Automatic wake up mode */
     30          #define MCR_ABOM     ((u32)0x00000040) /* Automatic bus-off management */
     31          #define MCR_TTCM     ((u32)0x00000080) /* time triggered communication */
     32          
     33          /* CAN Master Status Register bits */
     34          #define MSR_INAK     ((u32)0x00000001)    /* Initialization acknowledge */
     35          #define MSR_WKUI     ((u32)0x00000008)    /* Wake-up interrupt */
     36          #define MSR_SLAKI    ((u32)0x00000010)    /* Sleep acknowledge interrupt */
     37          
     38          /* CAN Transmit Status Register bits */
     39          #define TSR_RQCP0    ((u32)0x00000001)    /* Request completed mailbox0 */
     40          #define TSR_TXOK0    ((u32)0x00000002)    /* Transmission OK of mailbox0 */
     41          #define TSR_ABRQ0    ((u32)0x00000080)    /* Abort request for mailbox0 */
     42          #define TSR_RQCP1    ((u32)0x00000100)    /* Request completed mailbox1 */
     43          #define TSR_TXOK1    ((u32)0x00000200)    /* Transmission OK of mailbox1 */
     44          #define TSR_ABRQ1    ((u32)0x00008000)    /* Abort request for mailbox1 */
     45          #define TSR_RQCP2    ((u32)0x00010000)    /* Request completed mailbox2 */
     46          #define TSR_TXOK2    ((u32)0x00020000)    /* Transmission OK of mailbox2 */
     47          #define TSR_ABRQ2    ((u32)0x00800000)    /* Abort request for mailbox2 */
     48          #define TSR_TME0     ((u32)0x04000000)    /* Transmit mailbox 0 empty */
     49          #define TSR_TME1     ((u32)0x08000000)    /* Transmit mailbox 1 empty */
     50          #define TSR_TME2     ((u32)0x10000000)    /* Transmit mailbox 2 empty */
     51          
     52          /* CAN Receive FIFO 0 Register bits */
     53          #define RF0R_FULL0   ((u32)0x00000008)    /* FIFO 0 full */
     54          #define RF0R_FOVR0   ((u32)0x00000010)    /* FIFO 0 overrun */
     55          #define RF0R_RFOM0   ((u32)0x00000020)    /* Release FIFO 0 output mailbox */
     56          
     57          /* CAN Receive FIFO 1 Register bits */
     58          #define RF1R_FULL1   ((u32)0x00000008)    /* FIFO 1 full */
     59          #define RF1R_FOVR1   ((u32)0x00000010)    /* FIFO 1 overrun */
     60          #define RF1R_RFOM1   ((u32)0x00000020)    /* Release FIFO 1 output mailbox */
     61          
     62          /* CAN Error Status Register bits */
     63          #define ESR_EWGF     ((u32)0x00000001)    /* Error warning flag */
     64          #define ESR_EPVF     ((u32)0x00000002)    /* Error passive flag */
     65          #define ESR_BOFF     ((u32)0x00000004)    /* Bus-off flag */
     66          
     67          /* CAN Mailbox Transmit Request */
     68          #define TMIDxR_TXRQ  ((u32)0x00000001) /* Transmit mailbox request */
     69          
     70          /* CAN Filter Master Register bits */
     71          #define FMR_FINIT    ((u32)0x00000001) /* Filter init mode */
     72          
     73          
     74          /* Private macro -------------------------------------------------------------*/
     75          /* Private variables ---------------------------------------------------------*/
     76          /* Private function prototypes -----------------------------------------------*/
     77          static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit);
     78          
     79          /* Private functions ---------------------------------------------------------*/
     80          /*******************************************************************************
     81          * Function Name  : CAN_DeInit
     82          * Description    : Deinitializes the CAN peripheral registers to their default
     83          *                  reset values.
     84          * Input          : None.
     85          * Output         : None.
     86          * Return         : None.
     87          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     88          void CAN_DeInit(void)
     89          {
   \                     CAN_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     90            /* Enable CAN reset state */
     91            RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   4FF00070           MOV      R0,#+33554432
   \   00000008   ........           BL       RCC_APB1PeriphResetCmd
     92            /* Release CAN from reset state */
     93            RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   4FF00070           MOV      R0,#+33554432
   \   00000012   BDE80440           POP      {R2,LR}
   \   00000016   ........           B.W      RCC_APB1PeriphResetCmd
     94          }
     95          
     96          /*******************************************************************************
     97          * Function Name  : CAN_Init
     98          * Description    : Initializes the CAN peripheral according to the specified
     99          *                  parameters in the CAN_InitStruct.
    100          * Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure that
    101                             contains the configuration information for the CAN peripheral.
    102          * Output         : None.
    103          * Return         : Constant indicates initialization succeed which will be 
    104          *                  CANINITFAILED or CANINITOK.
    105          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    106          u8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct)
    107          {
    108            u8 InitStatus = 0;
    109            u16 WaitAck = 0;
    110          
    111            /* Check the parameters */
    112            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    113            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    114            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    115            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    116            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    117            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    118            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    119            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    120            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    121            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    122            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    123          
    124            /* Request initialisation */
    125            CAN->MCR = MCR_INRQ;
   \                     CAN_Init:
   \   00000000   ........           LDR.W    R1,??DataTable9  ;; 0x40006400
   \   00000004   0122               MOVS     R2,#+1
   \   00000006   0A60               STR      R2,[R1, #+0]
    126          
    127            /* ...and check acknowledged */
    128            if ((CAN->MSR & MSR_INAK) == 0)
   \   00000008   4A68               LDR      R2,[R1, #+4]
   \   0000000A   12F0010F           TST      R2,#0x1
   \   0000000E   01D1               BNE.N    ??CAN_Init_0
    129            {
    130              InitStatus = CANINITFAILED;
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   7047               BX       LR
    131            }
    132            else
    133            {
    134              /* Set the time triggered communication mode */
    135              if (CAN_InitStruct->CAN_TTCM == ENABLE)
   \                     ??CAN_Init_0:
   \   00000014   90F90020           LDRSB    R2,[R0, #+0]
   \   00000018   012A               CMP      R2,#+1
   \   0000001A   0A68               LDR      R2,[R1, #+0]
   \   0000001C   02D1               BNE.N    ??CAN_Init_1
    136              {
    137                CAN->MCR |= MCR_TTCM;
   \   0000001E   42F08002           ORR      R2,R2,#0x80
   \   00000022   01E0               B.N      ??CAN_Init_2
    138              }
    139              else
    140              {
    141                CAN->MCR &= ~MCR_TTCM;
   \                     ??CAN_Init_1:
   \   00000024   8023               MOVS     R3,#+128
   \   00000026   9A43               BICS     R2,R2,R3
   \                     ??CAN_Init_2:
   \   00000028   0A60               STR      R2,[R1, #+0]
    142              }
    143          
    144              /* Set the automatic bus-off management */
    145              if (CAN_InitStruct->CAN_ABOM == ENABLE)
   \   0000002A   90F90120           LDRSB    R2,[R0, #+1]
   \   0000002E   012A               CMP      R2,#+1
   \   00000030   0A68               LDR      R2,[R1, #+0]
   \   00000032   02D1               BNE.N    ??CAN_Init_3
    146              {
    147                CAN->MCR |= MCR_ABOM;
   \   00000034   42F04002           ORR      R2,R2,#0x40
   \   00000038   01E0               B.N      ??CAN_Init_4
    148              }
    149              else
    150              {
    151                CAN->MCR &= ~MCR_ABOM;
   \                     ??CAN_Init_3:
   \   0000003A   4023               MOVS     R3,#+64
   \   0000003C   9A43               BICS     R2,R2,R3
   \                     ??CAN_Init_4:
   \   0000003E   0A60               STR      R2,[R1, #+0]
    152              }
    153          
    154              /* Set the automatic wake-up mode */
    155              if (CAN_InitStruct->CAN_AWUM == ENABLE)
   \   00000040   90F90220           LDRSB    R2,[R0, #+2]
   \   00000044   012A               CMP      R2,#+1
   \   00000046   0A68               LDR      R2,[R1, #+0]
   \   00000048   02D1               BNE.N    ??CAN_Init_5
    156              {
    157                CAN->MCR |= MCR_AWUM;
   \   0000004A   42F02002           ORR      R2,R2,#0x20
   \   0000004E   01E0               B.N      ??CAN_Init_6
    158              }
    159              else
    160              {
    161                CAN->MCR &= ~MCR_AWUM;
   \                     ??CAN_Init_5:
   \   00000050   2023               MOVS     R3,#+32
   \   00000052   9A43               BICS     R2,R2,R3
   \                     ??CAN_Init_6:
   \   00000054   0A60               STR      R2,[R1, #+0]
    162              }
    163          
    164              /* Set the no automatic retransmission */
    165              if (CAN_InitStruct->CAN_NART == ENABLE)
   \   00000056   90F90320           LDRSB    R2,[R0, #+3]
   \   0000005A   012A               CMP      R2,#+1
   \   0000005C   0A68               LDR      R2,[R1, #+0]
   \   0000005E   02D1               BNE.N    ??CAN_Init_7
    166              {
    167                CAN->MCR |= MCR_NART;
   \   00000060   42F01002           ORR      R2,R2,#0x10
   \   00000064   01E0               B.N      ??CAN_Init_8
    168              }
    169              else
    170              {
    171                CAN->MCR &= ~MCR_NART;
   \                     ??CAN_Init_7:
   \   00000066   1023               MOVS     R3,#+16
   \   00000068   9A43               BICS     R2,R2,R3
   \                     ??CAN_Init_8:
   \   0000006A   0A60               STR      R2,[R1, #+0]
    172              }
    173          
    174              /* Set the receive FIFO locked mode */
    175              if (CAN_InitStruct->CAN_RFLM == ENABLE)
   \   0000006C   90F90420           LDRSB    R2,[R0, #+4]
   \   00000070   012A               CMP      R2,#+1
   \   00000072   0A68               LDR      R2,[R1, #+0]
   \   00000074   02D1               BNE.N    ??CAN_Init_9
    176              {
    177                CAN->MCR |= MCR_RFLM;
   \   00000076   42F00802           ORR      R2,R2,#0x8
   \   0000007A   01E0               B.N      ??CAN_Init_10
    178              }
    179              else
    180              {
    181                CAN->MCR &= ~MCR_RFLM;
   \                     ??CAN_Init_9:
   \   0000007C   0823               MOVS     R3,#+8
   \   0000007E   9A43               BICS     R2,R2,R3
   \                     ??CAN_Init_10:
   \   00000080   0A60               STR      R2,[R1, #+0]
    182              }
    183          
    184              /* Set the transmit FIFO priority */
    185              if (CAN_InitStruct->CAN_TXFP == ENABLE)
   \   00000082   90F90520           LDRSB    R2,[R0, #+5]
   \   00000086   012A               CMP      R2,#+1
   \   00000088   0A68               LDR      R2,[R1, #+0]
   \   0000008A   02D1               BNE.N    ??CAN_Init_11
    186              {
    187                CAN->MCR |= MCR_TXFP;
   \   0000008C   42F00402           ORR      R2,R2,#0x4
   \   00000090   01E0               B.N      ??CAN_Init_12
    188              }
    189              else
    190              {
    191                CAN->MCR &= ~MCR_TXFP;
   \                     ??CAN_Init_11:
   \   00000092   0423               MOVS     R3,#+4
   \   00000094   9A43               BICS     R2,R2,R3
   \                     ??CAN_Init_12:
   \   00000096   0A60               STR      R2,[R1, #+0]
    192              }
    193          
    194              /* Set the bit timing register */
    195              CAN->BTR = (u32)((u32)CAN_InitStruct->CAN_Mode << 30) | ((u32)CAN_InitStruct->CAN_SJW << 24) |
    196                         ((u32)CAN_InitStruct->CAN_BS1 << 16) | ((u32)CAN_InitStruct->CAN_BS2 << 20) |
    197                         ((u32)CAN_InitStruct->CAN_Prescaler - 1);
   \   00000098   8279               LDRB     R2,[R0, #+6]
   \   0000009A   C379               LDRB     R3,[R0, #+7]
   \   0000009C   1B06               LSLS     R3,R3,#+24
   \   0000009E   43EA8272           ORR      R2,R3,R2, LSL #+30
   \   000000A2   037A               LDRB     R3,[R0, #+8]
   \   000000A4   42EA0342           ORR      R2,R2,R3, LSL #+16
   \   000000A8   437A               LDRB     R3,[R0, #+9]
   \   000000AA   42EA0352           ORR      R2,R2,R3, LSL #+20
   \   000000AE   4089               LDRH     R0,[R0, #+10]
   \   000000B0   401E               SUBS     R0,R0,#+1
   \   000000B2   1043               ORRS     R0,R0,R2
   \   000000B4   C861               STR      R0,[R1, #+28]
    198          
    199              InitStatus = CANINITOK;
   \   000000B6   0120               MOVS     R0,#+1
    200          
    201              /* Request leave initialisation */
    202              CAN->MCR &= ~MCR_INRQ;
   \   000000B8   0A68               LDR      R2,[R1, #+0]
   \   000000BA   8243               BICS     R2,R2,R0
   \   000000BC   0A60               STR      R2,[R1, #+0]
    203          
    204              /* Wait the acknowledge */
    205              for(WaitAck = 0x400; WaitAck > 0x0; WaitAck--)
    206              {
    207              }
    208              
    209              /* ...and check acknowledged */
    210              if ((CAN->MSR & MSR_INAK) == MSR_INAK)
   \   000000BE   4968               LDR      R1,[R1, #+4]
   \   000000C0   11F0010F           TST      R1,#0x1
   \   000000C4   18BF               IT       NE 
    211              {
    212                InitStatus = CANINITFAILED;
   \   000000C6   0020               MOVNE    R0,#+0
    213              }
    214            }
    215          
    216            /* At this step, return the status of initialization */
    217            return InitStatus;
   \                     ??CAN_Init_13:
   \   000000C8   7047               BX       LR               ;; return
    218          }
    219          
    220          /*******************************************************************************
    221          * Function Name  : CAN_FilterInit
    222          * Description    : Initializes the CAN peripheral according to the specified
    223          *                  parameters in the CAN_FilterInitStruct.
    224          * Input          : CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef
    225          *                  structure that contains the configuration information.
    226          * Output         : None.
    227          * Return         : None.
    228          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    229          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    230          {
   \                     CAN_FilterInit:
   \   00000000   10B5               PUSH     {R4,LR}
    231            u16 FilterNumber_BitPos = 0;
    232          
    233            /* Check the parameters */
    234            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    235            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    236            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    237            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    238            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    239          
    240            FilterNumber_BitPos = 
    241            (u16)(((u16)0x0001) << ((u16)CAN_FilterInitStruct->CAN_FilterNumber));
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   90F90020           LDRSB    R2,[R0, #+0]
   \   00000008   01FA02F2           LSL      R2,R1,R2
   \   0000000C   92B2               UXTH     R2,R2
    242          
    243            /* Initialisation mode for the filter */
    244            CAN->FMR |= FMR_FINIT;
   \   0000000E   3C49               LDR.N    R1,??CAN_FilterInit_0  ;; 0x40006600
   \   00000010   0B68               LDR      R3,[R1, #+0]
   \   00000012   43F00103           ORR      R3,R3,#0x1
   \   00000016   0B60               STR      R3,[R1, #+0]
    245          
    246            /* Filter Deactivation */
    247            CAN->FA1R &= ~(u32)FilterNumber_BitPos;
   \   00000018   D343               MVNS     R3,R2
   \   0000001A   D1F81CC0           LDR      R12,[R1, #+28]
   \   0000001E   03EA0C0C           AND      R12,R3,R12
   \   00000022   C1F81CC0           STR      R12,[R1, #+28]
    248          
    249            /* Filter Scale */
    250            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
   \   00000026   90F802C0           LDRB     R12,[R0, #+2]
   \   0000002A   BCF1000F           CMP      R12,#+0
   \   0000002E   19D1               BNE.N    ??CAN_FilterInit_1
    251            {
    252              /* 16-bit scale for the filter */
    253              CAN->FS1R &= ~(u32)FilterNumber_BitPos;
   \   00000030   D1F80CC0           LDR      R12,[R1, #+12]
   \   00000034   03EA0C0C           AND      R12,R3,R12
   \   00000038   C1F80CC0           STR      R12,[R1, #+12]
    254          
    255              /* First 16-bit identifier and First 16-bit mask */
    256              /* Or First 16-bit identifier and Second 16-bit identifier */
    257              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    258              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    259                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
   \   0000003C   90F800C0           LDRB     R12,[R0, #+0]
   \   00000040   B0F80AE0           LDRH     LR,[R0, #+10]
   \   00000044   C488               LDRH     R4,[R0, #+6]
   \   00000046   44EA0E4E           ORR      LR,R4,LR, LSL #+16
   \   0000004A   2E4C               LDR.N    R4,??CAN_FilterInit_0+0x4  ;; 0x40006640
   \   0000004C   44F83CE0           STR      LR,[R4, R12, LSL #+3]
    260          
    261              /* Second 16-bit identifier and Second 16-bit mask */
    262              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    263              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    264              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    265                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh);
   \   00000050   B0F808E0           LDRH     LR,[R0, #+8]
   \   00000054   8488               LDRH     R4,[R0, #+4]
   \   00000056   44EA0E4E           ORR      LR,R4,LR, LSL #+16
   \   0000005A   2A4C               LDR.N    R4,??CAN_FilterInit_0+0x4  ;; 0x40006640
   \   0000005C   04EBCC0C           ADD      R12,R4,R12, LSL #+3
   \   00000060   CCF804E0           STR      LR,[R12, #+4]
    266            }
    267            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
   \                     ??CAN_FilterInit_1:
   \   00000064   90F802C0           LDRB     R12,[R0, #+2]
   \   00000068   BCF1010F           CMP      R12,#+1
   \   0000006C   19D1               BNE.N    ??CAN_FilterInit_2
    268            {
    269              /* 32-bit scale for the filter */
    270              CAN->FS1R |= FilterNumber_BitPos;
   \   0000006E   D1F80CC0           LDR      R12,[R1, #+12]
   \   00000072   42EA0C0C           ORR      R12,R2,R12
   \   00000076   C1F80CC0           STR      R12,[R1, #+12]
    271          
    272              /* 32-bit identifier or First 32-bit identifier */
    273              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    274              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    275                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterIdLow);
   \   0000007A   90F800C0           LDRB     R12,[R0, #+0]
   \   0000007E   B0F804E0           LDRH     LR,[R0, #+4]
   \   00000082   C488               LDRH     R4,[R0, #+6]
   \   00000084   44EA0E4E           ORR      LR,R4,LR, LSL #+16
   \   00000088   1E4C               LDR.N    R4,??CAN_FilterInit_0+0x4  ;; 0x40006640
   \   0000008A   44F83CE0           STR      LR,[R4, R12, LSL #+3]
    276          
    277              /* 32-bit mask or Second 32-bit identifier */
    278              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    279              ((u32)((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    280                  ((u32)0x0000FFFF & CAN_FilterInitStruct->CAN_FilterMaskIdLow);
   \   0000008E   B0F808E0           LDRH     LR,[R0, #+8]
   \   00000092   4489               LDRH     R4,[R0, #+10]
   \   00000094   44EA0E4E           ORR      LR,R4,LR, LSL #+16
   \   00000098   1A4C               LDR.N    R4,??CAN_FilterInit_0+0x4  ;; 0x40006640
   \   0000009A   04EBCC0C           ADD      R12,R4,R12, LSL #+3
   \   0000009E   CCF804E0           STR      LR,[R12, #+4]
    281          
    282            }
    283          
    284            /* Filter Mode */
    285            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
   \                     ??CAN_FilterInit_2:
   \   000000A2   90F801C0           LDRB     R12,[R0, #+1]
   \   000000A6   BCF1000F           CMP      R12,#+0
   \   000000AA   06D1               BNE.N    ??CAN_FilterInit_3
    286            {
    287              /*Id/Mask mode for the filter*/
    288              CAN->FM1R &= ~(u32)FilterNumber_BitPos;
   \   000000AC   D1F804C0           LDR      R12,[R1, #+4]
   \   000000B0   03EA0C0C           AND      R12,R3,R12
   \   000000B4   C1F804C0           STR      R12,[R1, #+4]
   \   000000B8   05E0               B.N      ??CAN_FilterInit_4
    289            }
    290            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    291            {
    292              /*Identifier list mode for the filter*/
    293              CAN->FM1R |= (u32)FilterNumber_BitPos;
   \                     ??CAN_FilterInit_3:
   \   000000BA   D1F804C0           LDR      R12,[R1, #+4]
   \   000000BE   42EA0C0C           ORR      R12,R2,R12
   \   000000C2   C1F804C0           STR      R12,[R1, #+4]
    294            }
    295          
    296            /* Filter FIFO assignment */
    297            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO0)
   \                     ??CAN_FilterInit_4:
   \   000000C6   B0F80CC0           LDRH     R12,[R0, #+12]
   \   000000CA   BCF1000F           CMP      R12,#+0
   \   000000CE   04D1               BNE.N    ??CAN_FilterInit_5
    298            {
    299              /* FIFO 0 assignation for the filter */
    300              CAN->FFA1R &= ~(u32)FilterNumber_BitPos;
   \   000000D0   D1F814C0           LDR      R12,[R1, #+20]
   \   000000D4   03EA0C03           AND      R3,R3,R12
   \   000000D8   04E0               B.N      ??CAN_FilterInit_6
    301            }
    302            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_FilterFIFO1)
   \                     ??CAN_FilterInit_5:
   \   000000DA   BCF1010F           CMP      R12,#+1
   \   000000DE   02D1               BNE.N    ??CAN_FilterInit_7
    303            {
    304              /* FIFO 1 assignation for the filter */
    305              CAN->FFA1R |= (u32)FilterNumber_BitPos;
   \   000000E0   4B69               LDR      R3,[R1, #+20]
   \   000000E2   1343               ORRS     R3,R2,R3
   \                     ??CAN_FilterInit_6:
   \   000000E4   4B61               STR      R3,[R1, #+20]
    306            }
    307            
    308            /* Filter activation */
    309            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
   \                     ??CAN_FilterInit_7:
   \   000000E6   90F90E00           LDRSB    R0,[R0, #+14]
   \   000000EA   0128               CMP      R0,#+1
   \   000000EC   02D1               BNE.N    ??CAN_FilterInit_8
    310            {
    311              CAN->FA1R |= FilterNumber_BitPos;
   \   000000EE   C869               LDR      R0,[R1, #+28]
   \   000000F0   1043               ORRS     R0,R2,R0
   \   000000F2   C861               STR      R0,[R1, #+28]
    312            }
    313          
    314            /* Leave the initialisation mode for the filter */
    315            CAN->FMR &= ~FMR_FINIT;
   \                     ??CAN_FilterInit_8:
   \   000000F4   0868               LDR      R0,[R1, #+0]
   \   000000F6   0122               MOVS     R2,#+1
   \   000000F8   9043               BICS     R0,R0,R2
   \   000000FA   0860               STR      R0,[R1, #+0]
    316          }
   \   000000FC   10BD               POP      {R4,PC}          ;; return
   \   000000FE   00BF               Nop      
   \                     ??CAN_FilterInit_0:
   \   00000100   00660040           DC32     0x40006600
   \   00000104   40660040           DC32     0x40006640
    317          
    318          /*******************************************************************************
    319          * Function Name  : CAN_StructInit
    320          * Description    : Fills each CAN_InitStruct member with its default value.
    321          * Input          : CAN_InitStruct: pointer to a CAN_InitTypeDef structure which
    322          *                  will be initialized.
    323          * Output         : None.
    324          * Return         : None.
    325          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    326          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    327          {
    328            /* Reset CAN init structure parameters values */
    329          
    330            /* Initialize the time triggered communication mode */
    331            CAN_InitStruct->CAN_TTCM = DISABLE;
   \                     CAN_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0170               STRB     R1,[R0, #+0]
    332          
    333            /* Initialize the automatic bus-off management */
    334            CAN_InitStruct->CAN_ABOM = DISABLE;
   \   00000004   4170               STRB     R1,[R0, #+1]
    335          
    336            /* Initialize the automatic wake-up mode */
    337            CAN_InitStruct->CAN_AWUM = DISABLE;
   \   00000006   8170               STRB     R1,[R0, #+2]
    338          
    339            /* Initialize the no automatic retransmission */
    340            CAN_InitStruct->CAN_NART = DISABLE;
   \   00000008   C170               STRB     R1,[R0, #+3]
    341          
    342            /* Initialize the receive FIFO locked mode */
    343            CAN_InitStruct->CAN_RFLM = DISABLE;
   \   0000000A   0171               STRB     R1,[R0, #+4]
    344          
    345            /* Initialize the transmit FIFO priority */
    346            CAN_InitStruct->CAN_TXFP = DISABLE;
   \   0000000C   4171               STRB     R1,[R0, #+5]
    347          
    348            /* Initialize the CAN_Mode member */
    349            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
   \   0000000E   8171               STRB     R1,[R0, #+6]
    350          
    351            /* Initialize the CAN_SJW member */
    352            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
   \   00000010   C171               STRB     R1,[R0, #+7]
    353          
    354            /* Initialize the CAN_BS1 member */
    355            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
   \   00000012   0321               MOVS     R1,#+3
   \   00000014   0172               STRB     R1,[R0, #+8]
    356          
    357            /* Initialize the CAN_BS2 member */
    358            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
   \   00000016   0221               MOVS     R1,#+2
   \   00000018   4172               STRB     R1,[R0, #+9]
    359          
    360            /* Initialize the CAN_Prescaler member */
    361            CAN_InitStruct->CAN_Prescaler = 1;
   \   0000001A   0121               MOVS     R1,#+1
   \   0000001C   4181               STRH     R1,[R0, #+10]
    362          }
   \   0000001E   7047               BX       LR               ;; return
    363          
    364          /*******************************************************************************
    365          * Function Name  : CAN_ITConfig
    366          * Description    : Enables or disables the specified CAN interrupts.
    367          * Input          : - CAN_IT: specifies the CAN interrupt sources to be enabled or
    368          *                    disabled.
    369          *                    This parameter can be: CAN_IT_TME, CAN_IT_FMP0, CAN_IT_FF0,
    370          *                                           CAN_IT_FOV0, CAN_IT_FMP1, CAN_IT_FF1,
    371          *                                           CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV,
    372          *                                           CAN_IT_LEC, CAN_IT_ERR, CAN_IT_WKU or
    373          *                                           CAN_IT_SLK.
    374          *                  - NewState: new state of the CAN interrupts.
    375          *                    This parameter can be: ENABLE or DISABLE.
    376          * Output         : None.
    377          * Return         : None.
    378          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    379          void CAN_ITConfig(u32 CAN_IT, FunctionalState NewState)
    380          {
    381            /* Check the parameters */
    382            assert_param(IS_CAN_ITConfig(CAN_IT));
    383            assert_param(IS_FUNCTIONAL_STATE(NewState));
    384          
    385            if (NewState != DISABLE)
   \                     CAN_ITConfig:
   \   00000000   044A               LDR.N    R2,??CAN_ITConfig_0  ;; 0x40006414
   \   00000002   0029               CMP      R1,#+0
   \   00000004   1168               LDR      R1,[R2, #+0]
   \   00000006   01D0               BEQ.N    ??CAN_ITConfig_1
    386            {
    387              /* Enable the selected CAN interrupt */
    388              CAN->IER |= CAN_IT;
   \   00000008   0843               ORRS     R0,R0,R1
   \   0000000A   01E0               B.N      ??CAN_ITConfig_2
    389            }
    390            else
    391            {
    392              /* Disable the selected CAN interrupt */
    393              CAN->IER &= ~CAN_IT;
   \                     ??CAN_ITConfig_1:
   \   0000000C   C043               MVNS     R0,R0
   \   0000000E   0840               ANDS     R0,R0,R1
   \                     ??CAN_ITConfig_2:
   \   00000010   1060               STR      R0,[R2, #+0]
    394            }
    395          }
   \   00000012   7047               BX       LR               ;; return
   \                     ??CAN_ITConfig_0:
   \   00000014   14640040           DC32     0x40006414
    396          
    397          /*******************************************************************************
    398          * Function Name  : CAN_Transmit
    399          * Description    : Initiates the transmission of a message.
    400          * Input          : TxMessage: pointer to a structure which contains CAN Id, CAN
    401          *                  DLC and CAN datas.
    402          * Output         : None.
    403          * Return         : The number of the mailbox that is used for transmission
    404          *                  or CAN_NO_MB if there is no empty mailbox.
    405          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    406          u8 CAN_Transmit(CanTxMsg* TxMessage)
    407          {
   \                     CAN_Transmit:
   \   00000000   80B5               PUSH     {R7,LR}
   \   00000002   0100               MOVS     R1,R0
    408            u8 TransmitMailbox = 0;
    409          
    410            /* Check the parameters */
    411            assert_param(IS_CAN_STDID(TxMessage->StdId));
    412            assert_param(IS_CAN_EXTID(TxMessage->StdId));
    413            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    414            assert_param(IS_CAN_RTR(TxMessage->RTR));
    415            assert_param(IS_CAN_DLC(TxMessage->DLC));
    416          
    417            /* Select one empty transmit mailbox */
    418            if ((CAN->TSR&TSR_TME0) == TSR_TME0)
   \   00000004   ....               LDR.N    R0,??DataTable3  ;; 0x40006408
   \   00000006   0268               LDR      R2,[R0, #+0]
   \   00000008   12F0806F           TST      R2,#0x4000000
   \   0000000C   01D0               BEQ.N    ??CAN_Transmit_0
    419            {
    420              TransmitMailbox = 0;
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   06E0               B.N      ??CAN_Transmit_1
    421            }
    422            else if ((CAN->TSR&TSR_TME1) == TSR_TME1)
   \                     ??CAN_Transmit_0:
   \   00000012   0268               LDR      R2,[R0, #+0]
   \   00000014   12F0006F           TST      R2,#0x8000000
   \   00000018   1DD0               BEQ.N    ??CAN_Transmit_2
    423            {
    424              TransmitMailbox = 1;
   \   0000001A   0120               MOVS     R0,#+1
    425            }
    426            else if ((CAN->TSR&TSR_TME2) == TSR_TME2)
    427            {
    428              TransmitMailbox = 2;
    429            }
    430            else
    431            {
    432              TransmitMailbox = CAN_NO_MB;
    433            }
    434          
    435            if (TransmitMailbox != CAN_NO_MB)
   \                     ??CAN_Transmit_3:
   \   0000001C   0428               CMP      R0,#+4
   \   0000001E   76D0               BEQ.N    ??CAN_Transmit_4
    436            {
    437              /* Set up the Id */
    438              CAN->sTxMailBox[TransmitMailbox].TIR &= TMIDxR_TXRQ;
   \                     ??CAN_Transmit_1:
   \   00000020   0201               LSLS     R2,R0,#+4
   \   00000022   3B4B               LDR.N    R3,??CAN_Transmit_5  ;; 0x40006580
   \   00000024   D358               LDR      R3,[R2, R3]
   \   00000026   03F00103           AND      R3,R3,#0x1
   \   0000002A   DFF8E4C0           LDR.W    R12,??CAN_Transmit_5  ;; 0x40006580
   \   0000002E   42F80C30           STR      R3,[R2, R12]
    439              if (TxMessage->IDE == CAN_ID_STD)
   \   00000032   0B7A               LDRB     R3,[R1, #+8]
   \   00000034   BBB9               CBNZ     R3,??CAN_Transmit_6
    440              {
    441                TxMessage->StdId &= (u32)0x000007FF;
    442                TxMessage->StdId = TxMessage->StdId << 21;
   \   00000036   0B68               LDR      R3,[R1, #+0]
   \   00000038   5B05               LSLS     R3,R3,#+21
   \   0000003A   0B60               STR      R3,[R1, #+0]
    443                
    444                CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->StdId | TxMessage->IDE |
    445                                                         TxMessage->RTR);
   \   0000003C   52F80CC0           LDR      R12,[R2, R12]
   \   00000040   91F809E0           LDRB     LR,[R1, #+9]
   \   00000044   4EEA0303           ORR      R3,LR,R3
   \   00000048   43EA0C03           ORR      R3,R3,R12
   \   0000004C   DFF8C0C0           LDR.W    R12,??CAN_Transmit_5  ;; 0x40006580
   \   00000050   42F80C30           STR      R3,[R2, R12]
   \   00000054   1DE0               B.N      ??CAN_Transmit_7
    446              }
   \                     ??CAN_Transmit_2:
   \   00000056   0068               LDR      R0,[R0, #+0]
   \   00000058   10F0805F           TST      R0,#0x10000000
   \   0000005C   01D0               BEQ.N    ??CAN_Transmit_8
   \   0000005E   0220               MOVS     R0,#+2
   \   00000060   DCE7               B.N      ??CAN_Transmit_3
   \                     ??CAN_Transmit_8:
   \   00000062   0420               MOVS     R0,#+4
   \   00000064   02BD               POP      {R1,PC}
    447              else
    448              {
    449                TxMessage->ExtId &= (u32)0x1FFFFFFF;
    450                TxMessage->ExtId <<= 3;
   \                     ??CAN_Transmit_6:
   \   00000066   D1F804C0           LDR      R12,[R1, #+4]
   \   0000006A   4FEACC0C           LSL      R12,R12,#+3
   \   0000006E   C1F804C0           STR      R12,[R1, #+4]
    451          
    452                CAN->sTxMailBox[TransmitMailbox].TIR |= (TxMessage->ExtId | TxMessage->IDE | 
    453                                                         TxMessage->RTR);
   \   00000072   DFF89CE0           LDR.W    LR,??CAN_Transmit_5  ;; 0x40006580
   \   00000076   52F80EE0           LDR      LR,[R2, LR]
   \   0000007A   43EA0C03           ORR      R3,R3,R12
   \   0000007E   91F809C0           LDRB     R12,[R1, #+9]
   \   00000082   4CEA0303           ORR      R3,R12,R3
   \   00000086   43EA0E03           ORR      R3,R3,LR
   \   0000008A   DFF884C0           LDR.W    R12,??CAN_Transmit_5  ;; 0x40006580
   \   0000008E   42F80C30           STR      R3,[R2, R12]
    454              }
    455              
    456              /* Set up the DLC */
    457              TxMessage->DLC &= (u8)0x0000000F;
   \                     ??CAN_Transmit_7:
   \   00000092   8B7A               LDRB     R3,[R1, #+10]
   \   00000094   03F00F03           AND      R3,R3,#0xF
   \   00000098   8B72               STRB     R3,[R1, #+10]
    458              CAN->sTxMailBox[TransmitMailbox].TDTR &= (u32)0xFFFFFFF0;
   \   0000009A   6346               MOV      R3,R12
   \   0000009C   D318               ADDS     R3,R2,R3
   \   0000009E   D3F804C0           LDR      R12,[R3, #+4]
   \   000000A2   4FF00F0E           MOV      LR,#+15
   \   000000A6   2CEA0E0C           BIC      R12,R12,LR
   \   000000AA   C3F804C0           STR      R12,[R3, #+4]
    459              CAN->sTxMailBox[TransmitMailbox].TDTR |= TxMessage->DLC;
   \   000000AE   D3F804C0           LDR      R12,[R3, #+4]
   \   000000B2   91F80AE0           LDRB     LR,[R1, #+10]
   \   000000B6   4EEA0C0C           ORR      R12,LR,R12
   \   000000BA   C3F804C0           STR      R12,[R3, #+4]
    460          
    461              /* Set up the data field */
    462              CAN->sTxMailBox[TransmitMailbox].TDLR = (((u32)TxMessage->Data[3] << 24) | 
    463                                                       ((u32)TxMessage->Data[2] << 16) |
    464                                                       ((u32)TxMessage->Data[1] << 8) | 
    465                                                       ((u32)TxMessage->Data[0]));
   \   000000BE   91F80EC0           LDRB     R12,[R1, #+14]
   \   000000C2   91F80DE0           LDRB     LR,[R1, #+13]
   \   000000C6   4FEA0E4E           LSL      LR,LR,#+16
   \   000000CA   4EEA0C6C           ORR      R12,LR,R12, LSL #+24
   \   000000CE   91F80CE0           LDRB     LR,[R1, #+12]
   \   000000D2   4CEA0E2C           ORR      R12,R12,LR, LSL #+8
   \   000000D6   91F80BE0           LDRB     LR,[R1, #+11]
   \   000000DA   4EEA0C0C           ORR      R12,LR,R12
   \   000000DE   C3F808C0           STR      R12,[R3, #+8]
    466              CAN->sTxMailBox[TransmitMailbox].TDHR = (((u32)TxMessage->Data[7] << 24) | 
    467                                                       ((u32)TxMessage->Data[6] << 16) |
    468                                                       ((u32)TxMessage->Data[5] << 8) |
    469                                                       ((u32)TxMessage->Data[4]));
   \   000000E2   91F812C0           LDRB     R12,[R1, #+18]
   \   000000E6   91F811E0           LDRB     LR,[R1, #+17]
   \   000000EA   4FEA0E4E           LSL      LR,LR,#+16
   \   000000EE   4EEA0C6C           ORR      R12,LR,R12, LSL #+24
   \   000000F2   91F810E0           LDRB     LR,[R1, #+16]
   \   000000F6   4CEA0E2C           ORR      R12,R12,LR, LSL #+8
   \   000000FA   C97B               LDRB     R1,[R1, #+15]
   \   000000FC   41EA0C01           ORR      R1,R1,R12
   \   00000100   D960               STR      R1,[R3, #+12]
    470          
    471              /* Request transmission */
    472              CAN->sTxMailBox[TransmitMailbox].TIR |= TMIDxR_TXRQ;
   \   00000102   0349               LDR.N    R1,??CAN_Transmit_5  ;; 0x40006580
   \   00000104   5158               LDR      R1,[R2, R1]
   \   00000106   41F00101           ORR      R1,R1,#0x1
   \   0000010A   014B               LDR.N    R3,??CAN_Transmit_5  ;; 0x40006580
   \   0000010C   D150               STR      R1,[R2, R3]
    473            }
    474          
    475            return TransmitMailbox;
   \                     ??CAN_Transmit_4:
   \   0000010E   02BD               POP      {R1,PC}          ;; return
   \                     ??CAN_Transmit_5:
   \   00000110   80650040           DC32     0x40006580
    476          }
    477          
    478          /*******************************************************************************
    479          * Function Name  : CAN_TransmitStatus
    480          * Description    : Checks the transmission of a message.
    481          * Input          : TransmitMailbox: the number of the mailbox that is used for
    482          *                  transmission.
    483          * Output         : None.
    484          * Return         : CANTXOK if the CAN driver transmits the message, CANTXFAILED
    485          *                  in an other case.
    486          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    487          u8 CAN_TransmitStatus(u8 TransmitMailbox)
    488          {
    489            /* RQCP, TXOK and TME bits */
    490            u8 State = 0;
   \                     CAN_TransmitStatus:
   \   00000000   0022               MOVS     R2,#+0
    491          
    492            /* Check the parameters */
    493            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    494          
    495            switch (TransmitMailbox)
   \   00000002   ....               LDR.N    R1,??DataTable3  ;; 0x40006408
   \   00000004   20B1               CBZ      R0,??CAN_TransmitStatus_0
   \   00000006   0128               CMP      R0,#+1
   \   00000008   11D0               BEQ.N    ??CAN_TransmitStatus_1
   \   0000000A   0228               CMP      R0,#+2
   \   0000000C   1FD0               BEQ.N    ??CAN_TransmitStatus_2
   \   0000000E   2DE0               B.N      ??CAN_TransmitStatus_3
    496            {
    497              case (0): State |= (u8)((CAN->TSR & TSR_RQCP0) << 2);
   \                     ??CAN_TransmitStatus_0:
   \   00000010   0868               LDR      R0,[R1, #+0]
   \   00000012   00F00100           AND      R0,R0,#0x1
   \   00000016   8000               LSLS     R0,R0,#+2
    498                State |= (u8)((CAN->TSR & TSR_TXOK0) >> 0);
   \   00000018   0A68               LDR      R2,[R1, #+0]
   \   0000001A   02F00202           AND      R2,R2,#0x2
   \   0000001E   1043               ORRS     R0,R2,R0
    499                State |= (u8)((CAN->TSR & TSR_TME0) >> 26);
   \   00000020   0968               LDR      R1,[R1, #+0]
   \   00000022   01F08061           AND      R1,R1,#0x4000000
   \   00000026   890E               LSRS     R1,R1,#+26
   \   00000028   41EA0002           ORR      R2,R1,R0
   \   0000002C   1EE0               B.N      ??CAN_TransmitStatus_3
    500                break;
    501              case (1): State |= (u8)((CAN->TSR & TSR_RQCP1) >> 6);
   \                     ??CAN_TransmitStatus_1:
   \   0000002E   0868               LDR      R0,[R1, #+0]
   \   00000030   00F48070           AND      R0,R0,#0x100
   \   00000034   8009               LSRS     R0,R0,#+6
    502                State |= (u8)((CAN->TSR & TSR_TXOK1) >> 8);
   \   00000036   0A68               LDR      R2,[R1, #+0]
   \   00000038   02F40072           AND      R2,R2,#0x200
   \   0000003C   120A               LSRS     R2,R2,#+8
   \   0000003E   1043               ORRS     R0,R2,R0
    503                State |= (u8)((CAN->TSR & TSR_TME1) >> 27);
   \   00000040   0968               LDR      R1,[R1, #+0]
   \   00000042   01F00061           AND      R1,R1,#0x8000000
   \   00000046   C90E               LSRS     R1,R1,#+27
   \   00000048   41EA0002           ORR      R2,R1,R0
   \   0000004C   0EE0               B.N      ??CAN_TransmitStatus_3
    504                break;
    505              case (2): State |= (u8)((CAN->TSR & TSR_RQCP2) >> 14);
   \                     ??CAN_TransmitStatus_2:
   \   0000004E   0868               LDR      R0,[R1, #+0]
   \   00000050   00F48030           AND      R0,R0,#0x10000
   \   00000054   800B               LSRS     R0,R0,#+14
    506                State |= (u8)((CAN->TSR & TSR_TXOK2) >> 16);
   \   00000056   0A68               LDR      R2,[R1, #+0]
   \   00000058   02F40032           AND      R2,R2,#0x20000
   \   0000005C   120C               LSRS     R2,R2,#+16
   \   0000005E   1043               ORRS     R0,R2,R0
    507                State |= (u8)((CAN->TSR & TSR_TME2) >> 28);
   \   00000060   0968               LDR      R1,[R1, #+0]
   \   00000062   01F08051           AND      R1,R1,#0x10000000
   \   00000066   090F               LSRS     R1,R1,#+28
   \   00000068   41EA0002           ORR      R2,R1,R0
    508                break;
    509              default:
    510                State = CANTXFAILED;
    511                break;
    512            }
    513          
    514            switch (State)
   \                     ??CAN_TransmitStatus_3:
   \   0000006C   12B1               CBZ      R2,??CAN_TransmitStatus_4
   \   0000006E   072A               CMP      R2,#+7
   \   00000070   04D0               BEQ.N    ??CAN_TransmitStatus_5
   \   00000072   01E0               B.N      ??CAN_TransmitStatus_6
    515            {
    516                /* transmit pending  */
    517              case (0x0): State = CANTXPENDING;
   \                     ??CAN_TransmitStatus_4:
   \   00000074   0220               MOVS     R0,#+2
   \   00000076   7047               BX       LR
    518                break;
    519                /* transmit failed  */
    520              case (0x5): State = CANTXFAILED;
   \                     ??CAN_TransmitStatus_6:
   \   00000078   0020               MOVS     R0,#+0
   \   0000007A   7047               BX       LR
    521                break;
    522                /* transmit succedeed  */
    523              case (0x7): State = CANTXOK;
   \                     ??CAN_TransmitStatus_5:
   \   0000007C   0120               MOVS     R0,#+1
    524                break;
    525              default:
    526                State = CANTXFAILED;
    527                break;
    528            }
    529          
    530            return State;
   \                     ??CAN_TransmitStatus_7:
   \   0000007E   7047               BX       LR               ;; return
    531          }
    532          
    533          /*******************************************************************************
    534          * Function Name  : CAN_CancelTransmit
    535          * Description    : Cancels a transmit request.
    536          * Input          : Mailbox number.
    537          * Output         : None.
    538          * Return         : None.
    539          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    540          void CAN_CancelTransmit(u8 Mailbox)
    541          {
    542            /* Check the parameters */
    543            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    544          
    545            /* abort transmission */
    546            switch (Mailbox)
   \                     CAN_CancelTransmit:
   \   00000000   ....               LDR.N    R1,??DataTable3  ;; 0x40006408
   \   00000002   40B1               CBZ      R0,??CAN_CancelTransmit_0
   \   00000004   0128               CMP      R0,#+1
   \   00000006   0AD0               BEQ.N    ??CAN_CancelTransmit_1
   \   00000008   0228               CMP      R0,#+2
   \   0000000A   02BF               ITTT     EQ 
   \   0000000C   0868               LDREQ    R0,[R1, #+0]
   \   0000000E   40F40000           ORREQ    R0,R0,#0x800000
   \   00000012   0860               STREQ    R0,[R1, #+0]
   \   00000014   7047               BX       LR
    547            {
    548              case (0): CAN->TSR |= TSR_ABRQ0;
   \                     ??CAN_CancelTransmit_0:
   \   00000016   0868               LDR      R0,[R1, #+0]
   \   00000018   40F08000           ORR      R0,R0,#0x80
   \   0000001C   02E0               B.N      ??CAN_CancelTransmit_2
    549                break;
    550              case (1): CAN->TSR |= TSR_ABRQ1;
   \                     ??CAN_CancelTransmit_1:
   \   0000001E   0868               LDR      R0,[R1, #+0]
   \   00000020   40F40040           ORR      R0,R0,#0x8000
   \                     ??CAN_CancelTransmit_2:
   \   00000024   0860               STR      R0,[R1, #+0]
    551                break;
    552              case (2): CAN->TSR |= TSR_ABRQ2;
    553                break;
    554              default:
    555                break;
    556            }
    557          }
   \                     ??CAN_CancelTransmit_3:
   \   00000026   7047               BX       LR               ;; return
    558          
    559          /*******************************************************************************
    560          * Function Name  : CAN_FIFORelease
    561          * Description    : Releases a FIFO.
    562          * Input          : FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    563          * Output         : None.
    564          * Return         : None.
    565          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    566          void CAN_FIFORelease(u8 FIFONumber)
    567          {
    568            /* Check the parameters */
    569            assert_param(IS_CAN_FIFO(FIFONumber));
    570          
    571            /* Release FIFO0 */
    572            if (FIFONumber == CAN_FIFO0)
   \                     CAN_FIFORelease:
   \   00000000   18B9               CBNZ     R0,??CAN_FIFORelease_0
    573            {
    574              CAN->RF0R = RF0R_RFOM0;
   \   00000002   ....               LDR.N    R0,??DataTable7  ;; 0x4000640c
   \   00000004   2021               MOVS     R1,#+32
   \   00000006   0160               STR      R1,[R0, #+0]
   \   00000008   7047               BX       LR
    575            }
    576            /* Release FIFO1 */
    577            else /* FIFONumber == CAN_FIFO1 */
    578            {
    579              CAN->RF1R = RF1R_RFOM1;
   \                     ??CAN_FIFORelease_0:
   \   0000000A   ....               LDR.N    R0,??DataTable7  ;; 0x4000640c
   \   0000000C   2021               MOVS     R1,#+32
   \   0000000E   4160               STR      R1,[R0, #+4]
    580            }
    581          }
   \                     ??CAN_FIFORelease_1:
   \   00000010   7047               BX       LR               ;; return
    582          
    583          /*******************************************************************************
    584          * Function Name  : CAN_MessagePending
    585          * Description    : Returns the number of pending messages.
    586          * Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    587          * Output         : None.
    588          * Return         : NbMessage which is the number of pending message.
    589          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    590          u8 CAN_MessagePending(u8 FIFONumber)
    591          {
    592            u8 MessagePending=0;
    593          
    594            /* Check the parameters */
    595            assert_param(IS_CAN_FIFO(FIFONumber));
    596          
    597            if (FIFONumber == CAN_FIFO0)
   \                     CAN_MessagePending:
   \   00000000   20B9               CBNZ     R0,??CAN_MessagePending_0
    598            {
    599              MessagePending = (u8)(CAN->RF0R&(u32)0x03);
   \   00000002   ....               LDR.N    R0,??DataTable7  ;; 0x4000640c
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   00F00300           AND      R0,R0,#0x3
   \   0000000A   7047               BX       LR
    600            }
    601            else if (FIFONumber == CAN_FIFO1)
   \                     ??CAN_MessagePending_0:
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   04D1               BNE.N    ??CAN_MessagePending_1
    602            {
    603              MessagePending = (u8)(CAN->RF1R&(u32)0x03);
   \   00000010   ....               LDR.N    R0,??DataTable7  ;; 0x4000640c
   \   00000012   4068               LDR      R0,[R0, #+4]
   \   00000014   00F00300           AND      R0,R0,#0x3
   \   00000018   7047               BX       LR
    604            }
    605            else
    606            {
    607              MessagePending = 0;
   \                     ??CAN_MessagePending_1:
   \   0000001A   0020               MOVS     R0,#+0
    608            }
    609            return MessagePending;
   \                     ??CAN_MessagePending_2:
   \   0000001C   7047               BX       LR               ;; return
    610          }
    611          
    612          /*******************************************************************************
    613          * Function Name  : CAN_Receive
    614          * Description    : Receives a message.
    615          * Input          : FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    616          * Output         : RxMessage: pointer to a structure which contains CAN Id,
    617          *                  CAN DLC, CAN datas and FMI number.
    618          * Return         : None.
    619          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    620          void CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage)
    621          {
    622            /* Check the parameters */
    623            assert_param(IS_CAN_FIFO(FIFONumber));
    624          
    625            /* Get the Id */
    626            RxMessage->IDE = (u8)0x04 & CAN->sFIFOMailBox[FIFONumber].RIR;
   \                     CAN_Receive:
   \   00000000   0201               LSLS     R2,R0,#+4
   \   00000002   1A4B               LDR.N    R3,??CAN_Receive_0  ;; 0x400065b0
   \   00000004   D358               LDR      R3,[R2, R3]
   \   00000006   13F00403           ANDS     R3,R3,#0x4
   \   0000000A   0B72               STRB     R3,[R1, #+8]
    627            if (RxMessage->IDE == CAN_ID_STD)
   \   0000000C   04D1               BNE.N    ??CAN_Receive_1
    628            {
    629              RxMessage->StdId = (u32)0x000007FF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 21);
   \   0000000E   174B               LDR.N    R3,??CAN_Receive_0  ;; 0x400065b0
   \   00000010   D358               LDR      R3,[R2, R3]
   \   00000012   5B0D               LSRS     R3,R3,#+21
   \   00000014   0B60               STR      R3,[R1, #+0]
   \   00000016   03E0               B.N      ??CAN_Receive_2
    630            }
    631            else
    632            {
    633              RxMessage->ExtId = (u32)0x1FFFFFFF & (CAN->sFIFOMailBox[FIFONumber].RIR >> 3);
   \                     ??CAN_Receive_1:
   \   00000018   144B               LDR.N    R3,??CAN_Receive_0  ;; 0x400065b0
   \   0000001A   D358               LDR      R3,[R2, R3]
   \   0000001C   DB08               LSRS     R3,R3,#+3
   \   0000001E   4B60               STR      R3,[R1, #+4]
    634            }
    635            
    636            RxMessage->RTR = (u8)0x02 & CAN->sFIFOMailBox[FIFONumber].RIR;
   \                     ??CAN_Receive_2:
   \   00000020   124B               LDR.N    R3,??CAN_Receive_0  ;; 0x400065b0
   \   00000022   D358               LDR      R3,[R2, R3]
   \   00000024   03F00203           AND      R3,R3,#0x2
   \   00000028   4B72               STRB     R3,[R1, #+9]
    637          
    638            /* Get the DLC */
    639            RxMessage->DLC = (u8)0x0F & CAN->sFIFOMailBox[FIFONumber].RDTR;
   \   0000002A   104B               LDR.N    R3,??CAN_Receive_0  ;; 0x400065b0
   \   0000002C   D218               ADDS     R2,R2,R3
   \   0000002E   5368               LDR      R3,[R2, #+4]
   \   00000030   03F00F03           AND      R3,R3,#0xF
   \   00000034   8B72               STRB     R3,[R1, #+10]
    640          
    641            /* Get the FMI */
    642            RxMessage->FMI = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDTR >> 8);
   \   00000036   5368               LDR      R3,[R2, #+4]
   \   00000038   1B0A               LSRS     R3,R3,#+8
   \   0000003A   CB74               STRB     R3,[R1, #+19]
    643          
    644            /* Get the data field */
    645            RxMessage->Data[0] = (u8)0xFF & CAN->sFIFOMailBox[FIFONumber].RDLR;
   \   0000003C   9368               LDR      R3,[R2, #+8]
   \   0000003E   CB72               STRB     R3,[R1, #+11]
    646            RxMessage->Data[1] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDLR >> 8);
   \   00000040   9368               LDR      R3,[R2, #+8]
   \   00000042   1B0A               LSRS     R3,R3,#+8
   \   00000044   0B73               STRB     R3,[R1, #+12]
    647            RxMessage->Data[2] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDLR >> 16);
   \   00000046   9368               LDR      R3,[R2, #+8]
   \   00000048   1B0C               LSRS     R3,R3,#+16
   \   0000004A   4B73               STRB     R3,[R1, #+13]
    648            RxMessage->Data[3] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDLR >> 24);
   \   0000004C   9368               LDR      R3,[R2, #+8]
   \   0000004E   1B0E               LSRS     R3,R3,#+24
   \   00000050   8B73               STRB     R3,[R1, #+14]
    649          
    650            RxMessage->Data[4] = (u8)0xFF & CAN->sFIFOMailBox[FIFONumber].RDHR;
   \   00000052   D368               LDR      R3,[R2, #+12]
   \   00000054   CB73               STRB     R3,[R1, #+15]
    651            RxMessage->Data[5] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 8);
   \   00000056   D368               LDR      R3,[R2, #+12]
   \   00000058   1B0A               LSRS     R3,R3,#+8
   \   0000005A   0B74               STRB     R3,[R1, #+16]
    652            RxMessage->Data[6] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 16);
   \   0000005C   D368               LDR      R3,[R2, #+12]
   \   0000005E   1B0C               LSRS     R3,R3,#+16
   \   00000060   4B74               STRB     R3,[R1, #+17]
    653            RxMessage->Data[7] = (u8)0xFF & (CAN->sFIFOMailBox[FIFONumber].RDHR >> 24);
   \   00000062   D268               LDR      R2,[R2, #+12]
   \   00000064   120E               LSRS     R2,R2,#+24
   \   00000066   8A74               STRB     R2,[R1, #+18]
    654          
    655            /* Release the FIFO */
    656            CAN_FIFORelease(FIFONumber);
   \   00000068   ....               B.N      CAN_FIFORelease
   \   0000006A   00BF               Nop      
   \                     ??CAN_Receive_0:
   \   0000006C   B0650040           DC32     0x400065b0
    657          }
    658          
    659          /*******************************************************************************
    660          * Function Name  : CAN_Sleep
    661          * Description    : Enters the low power mode.
    662          * Input          : None.
    663          * Output         : None.
    664          * Return         : CANSLEEPOK if sleep entered, CANSLEEPFAILED in an other case.
    665          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    666          u8 CAN_Sleep(void)
    667          {
    668            u8 SleepStatus = 0;
    669          
    670            /* Sleep mode entering request */
    671            CAN->MCR |= MCR_SLEEP;
   \                     CAN_Sleep:
   \   00000000   ....               LDR.N    R1,??DataTable9  ;; 0x40006400
   \   00000002   0868               LDR      R0,[R1, #+0]
   \   00000004   40F00200           ORR      R0,R0,#0x2
   \   00000008   0860               STR      R0,[R1, #+0]
    672            SleepStatus = CANSLEEPOK;
   \   0000000A   0120               MOVS     R0,#+1
    673          
    674            /* Sleep mode status */
    675            if ((CAN->MCR&MCR_SLEEP) == 0)
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   11F0020F           TST      R1,#0x2
   \   00000012   08BF               IT       EQ 
    676            {
    677              /* Sleep mode not entered */
    678              SleepStatus = CANSLEEPFAILED;
   \   00000014   0020               MOVEQ    R0,#+0
    679            }
    680          
    681            /* At this step, sleep mode status */
    682            return SleepStatus;
   \   00000016   7047               BX       LR               ;; return
    683          }
    684          
    685          /*******************************************************************************
    686          * Function Name  : CAN_WakeUp
    687          * Description    : Wakes the CAN up.
    688          * Input          : None.
    689          * Output         : None.
    690          * Return         : CANWAKEUPOK if sleep mode left, CANWAKEUPFAILED in an other
    691          *                  case.
    692          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    693          u8 CAN_WakeUp(void)
    694          {
    695            u8 WakeUpStatus = 0;
    696          
    697            /* Wake up request */
    698            CAN->MCR &= ~MCR_SLEEP;
   \                     CAN_WakeUp:
   \   00000000   ....               LDR.N    R1,??DataTable9  ;; 0x40006400
   \   00000002   0868               LDR      R0,[R1, #+0]
   \   00000004   0222               MOVS     R2,#+2
   \   00000006   9043               BICS     R0,R0,R2
   \   00000008   0860               STR      R0,[R1, #+0]
    699            WakeUpStatus = CANWAKEUPFAILED;
   \   0000000A   0020               MOVS     R0,#+0
    700          
    701            /* Sleep mode status */
    702            if ((CAN->MCR&MCR_SLEEP) == 0)
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   11F0020F           TST      R1,#0x2
   \   00000012   08BF               IT       EQ 
    703            {
    704              /* Sleep mode exited */
    705              WakeUpStatus = CANWAKEUPOK;
   \   00000014   0120               MOVEQ    R0,#+1
    706            }
    707          
    708            /* At this step, sleep mode status */
    709            return WakeUpStatus;
   \   00000016   7047               BX       LR               ;; return
    710          }
    711          
    712          /*******************************************************************************
    713          * Function Name  : CAN_GetFlagStatus
    714          * Description    : Checks whether the specified CAN flag is set or not.
    715          * Input          : CAN_FLAG: specifies the flag to check.
    716          *                  This parameter can be: CAN_FLAG_EWG, CAN_FLAG_EPV or
    717          *                                         CAN_FLAG_BOF.
    718          * Output         : None.
    719          * Return         : The new state of CAN_FLAG (SET or RESET).
    720          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    721          FlagStatus CAN_GetFlagStatus(u32 CAN_FLAG)
    722          {
    723            FlagStatus bitstatus = RESET;
    724          
    725            /* Check the parameters */
    726            assert_param(IS_CAN_FLAG(CAN_FLAG));
    727          
    728            /* Check the status of the specified CAN flag */
    729            if ((CAN->ESR & CAN_FLAG) != (u32)RESET)
   \                     CAN_GetFlagStatus:
   \   00000000   ....               LDR.N    R1,??DataTable11  ;; 0x40006418
   \   00000002   0968               LDR      R1,[R1, #+0]
   \   00000004   0840               ANDS     R0,R0,R1
   \   00000006   18BF               IT       NE 
   \   00000008   0120               MOVNE    R0,#+1
    730            {
    731              /* CAN_FLAG is set */
    732              bitstatus = SET;
    733            }
    734            else
    735            {
    736              /* CAN_FLAG is reset */
    737              bitstatus = RESET;
    738            }
    739            /* Return the CAN_FLAG status */
    740            return  bitstatus;
   \   0000000A   40B2               SXTB     R0,R0
   \   0000000C   7047               BX       LR               ;; return
    741          }
    742          
    743          /*******************************************************************************
    744          * Function Name  : CAN_ClearFlag
    745          * Description    : Clears the CAN's pending flags.
    746          * Input          : CAN_FLAG: specifies the flag to clear.
    747          * Output         : None.
    748          * Return         : None.
    749          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    750          void CAN_ClearFlag(u32 CAN_FLAG)
    751          {
    752            /* Check the parameters */
    753            assert_param(IS_CAN_FLAG(CAN_FLAG));
    754          
    755            /* Clear the selected CAN flags */
    756            CAN->ESR &= ~CAN_FLAG;
   \                     CAN_ClearFlag:
   \   00000000   ....               LDR.N    R1,??DataTable11  ;; 0x40006418
   \   00000002   0A68               LDR      R2,[R1, #+0]
   \   00000004   C043               MVNS     R0,R0
   \   00000006   1040               ANDS     R0,R0,R2
   \   00000008   0860               STR      R0,[R1, #+0]
    757          }
   \   0000000A   7047               BX       LR               ;; return
    758          
    759          /*******************************************************************************
    760          * Function Name  : CAN_GetITStatus
    761          * Description    : Checks whether the specified CAN interrupt has occurred or 
    762          *                  not.
    763          * Input          : CAN_IT: specifies the CAN interrupt source to check.
    764          *                  This parameter can be: CAN_IT_RQCP0, CAN_IT_RQCP1, CAN_IT_RQCP2,
    765          *                                         CAN_IT_FF0, CAN_IT_FOV0, CAN_IT_FF1,
    766          *                                         CAN_IT_FOV1, CAN_IT_EWG, CAN_IT_EPV, 
    767          *                                         CAN_IT_BOF, CAN_IT_WKU or CAN_IT_SLK.
    768          * Output         : None.
    769          * Return         : The new state of CAN_IT (SET or RESET).
    770          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    771          ITStatus CAN_GetITStatus(u32 CAN_IT)
    772          {
   \                     CAN_GetITStatus:
   \   00000000   80B5               PUSH     {R7,LR}
    773            ITStatus pendingbitstatus = RESET;
    774          
    775            /* Check the parameters */
    776            assert_param(IS_CAN_ITStatus(CAN_IT));
    777          
    778            switch (CAN_IT)
   \   00000002   ....               LDR.N    R2,??DataTable16  ;; 0x40006404
   \   00000004   0428               CMP      R0,#+4
   \   00000006   2ED0               BEQ.N    ??CAN_GetITStatus_0
   \   00000008   0528               CMP      R0,#+5
   \   0000000A   1ED0               BEQ.N    ??CAN_GetITStatus_1
   \   0000000C   0628               CMP      R0,#+6
   \   0000000E   21D0               BEQ.N    ??CAN_GetITStatus_2
   \   00000010   0728               CMP      R0,#+7
   \   00000012   22D0               BEQ.N    ??CAN_GetITStatus_3
   \   00000014   0828               CMP      R0,#+8
   \   00000016   29D0               BEQ.N    ??CAN_GetITStatus_4
   \   00000018   2028               CMP      R0,#+32
   \   0000001A   2AD0               BEQ.N    ??CAN_GetITStatus_5
   \   0000001C   4028               CMP      R0,#+64
   \   0000001E   2BD0               BEQ.N    ??CAN_GetITStatus_6
   \   00000020   4FF48071           MOV      R1,#+256
   \   00000024   8842               CMP      R0,R1
   \   00000026   2CD0               BEQ.N    ??CAN_GetITStatus_7
   \   00000028   4FF40071           MOV      R1,#+512
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   2BD0               BEQ.N    ??CAN_GetITStatus_8
   \   00000030   4FF48061           MOV      R1,#+1024
   \   00000034   8842               CMP      R0,R1
   \   00000036   2AD0               BEQ.N    ??CAN_GetITStatus_9
   \   00000038   4FF48031           MOV      R1,#+65536
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   2CD0               BEQ.N    ??CAN_GetITStatus_10
   \   00000040   4FF40031           MOV      R1,#+131072
   \   00000044   8842               CMP      R0,R1
   \   00000046   25D0               BEQ.N    ??CAN_GetITStatus_11
   \   00000048   2AE0               B.N      ??CAN_GetITStatus_12
    779            {
    780              case CAN_IT_RQCP0:
    781                pendingbitstatus = CheckITStatus(CAN->TSR, TSR_RQCP0);
   \                     ??CAN_GetITStatus_1:
   \   0000004A   0121               MOVS     R1,#+1
   \                     ??CAN_GetITStatus_13:
   \   0000004C   5068               LDR      R0,[R2, #+4]
   \                     ??CAN_GetITStatus_14:
   \   0000004E   ........           BL       CheckITStatus
   \   00000052   02BD               POP      {R1,PC}
    782                break;
    783              case CAN_IT_RQCP1:
    784                pendingbitstatus = CheckITStatus(CAN->TSR, TSR_RQCP1);
   \                     ??CAN_GetITStatus_2:
   \   00000054   4FF48071           MOV      R1,#+256
   \   00000058   F8E7               B.N      ??CAN_GetITStatus_13
    785                break;
    786              case CAN_IT_RQCP2:
    787                pendingbitstatus = CheckITStatus(CAN->TSR, TSR_RQCP2);
   \                     ??CAN_GetITStatus_3:
   \   0000005A   4FF48031           MOV      R1,#+65536
   \   0000005E   5068               LDR      R0,[R2, #+4]
   \                     ??CAN_GetITStatus_15:
   \   00000060   ........           BL       CheckITStatus
   \   00000064   02BD               POP      {R1,PC}
    788                break;
    789              case CAN_IT_FF0:
    790                pendingbitstatus = CheckITStatus(CAN->RF0R, RF0R_FULL0);
   \                     ??CAN_GetITStatus_0:
   \   00000066   0821               MOVS     R1,#+8
   \   00000068   9068               LDR      R0,[R2, #+8]
   \   0000006A   F0E7               B.N      ??CAN_GetITStatus_14
    791                break;
    792              case CAN_IT_FOV0:
    793                pendingbitstatus = CheckITStatus(CAN->RF0R, RF0R_FOVR0);
   \                     ??CAN_GetITStatus_4:
   \   0000006C   1021               MOVS     R1,#+16
   \   0000006E   9068               LDR      R0,[R2, #+8]
   \   00000070   F6E7               B.N      ??CAN_GetITStatus_15
    794                break;
    795              case CAN_IT_FF1:
    796                pendingbitstatus = CheckITStatus(CAN->RF1R, RF1R_FULL1);
   \                     ??CAN_GetITStatus_5:
   \   00000072   0821               MOVS     R1,#+8
   \   00000074   D068               LDR      R0,[R2, #+12]
   \   00000076   EAE7               B.N      ??CAN_GetITStatus_14
    797                break;
    798              case CAN_IT_FOV1:
    799                pendingbitstatus = CheckITStatus(CAN->RF1R, RF1R_FOVR1);
   \                     ??CAN_GetITStatus_6:
   \   00000078   1021               MOVS     R1,#+16
   \   0000007A   D068               LDR      R0,[R2, #+12]
   \                     ??CAN_GetITStatus_16:
   \   0000007C   ........           BL       CheckITStatus
   \   00000080   02BD               POP      {R1,PC}
    800                break;
    801              case CAN_IT_EWG:
    802                pendingbitstatus = CheckITStatus(CAN->ESR, ESR_EWGF);
   \                     ??CAN_GetITStatus_7:
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   5069               LDR      R0,[R2, #+20]
   \   00000086   E2E7               B.N      ??CAN_GetITStatus_14
    803                break;
    804              case CAN_IT_EPV:
    805                pendingbitstatus = CheckITStatus(CAN->ESR, ESR_EPVF);
   \                     ??CAN_GetITStatus_8:
   \   00000088   0221               MOVS     R1,#+2
   \   0000008A   5069               LDR      R0,[R2, #+20]
   \   0000008C   E8E7               B.N      ??CAN_GetITStatus_15
    806                break;
    807              case CAN_IT_BOF:
    808                pendingbitstatus = CheckITStatus(CAN->ESR, ESR_BOFF);
   \                     ??CAN_GetITStatus_9:
   \   0000008E   0421               MOVS     R1,#+4
   \   00000090   5069               LDR      R0,[R2, #+20]
   \   00000092   DCE7               B.N      ??CAN_GetITStatus_14
    809                break;
    810              case CAN_IT_SLK:
    811                pendingbitstatus = CheckITStatus(CAN->MSR, MSR_SLAKI);
   \                     ??CAN_GetITStatus_11:
   \   00000094   1021               MOVS     R1,#+16
   \   00000096   1068               LDR      R0,[R2, #+0]
   \   00000098   F0E7               B.N      ??CAN_GetITStatus_16
    812                break;
    813              case CAN_IT_WKU:
    814                pendingbitstatus = CheckITStatus(CAN->MSR, MSR_WKUI);
   \                     ??CAN_GetITStatus_10:
   \   0000009A   0821               MOVS     R1,#+8
   \   0000009C   1068               LDR      R0,[R2, #+0]
   \   0000009E   D6E7               B.N      ??CAN_GetITStatus_14
    815                break;
    816          
    817              default :
    818                pendingbitstatus = RESET;
   \                     ??CAN_GetITStatus_12:
   \   000000A0   0020               MOVS     R0,#+0
    819                break;
    820            }
    821          
    822            /* Return the CAN_IT status */
    823            return  pendingbitstatus;
   \                     ??CAN_GetITStatus_17:
   \   000000A2   02BD               POP      {R1,PC}          ;; return
    824          }
    825          
    826          /*******************************************************************************
    827          * Function Name  : CAN_ClearITPendingBit
    828          * Description    : Clears the CANs interrupt pending bits.
    829          * Input          : CAN_IT: specifies the interrupt pending bit to clear.
    830          * Output         : None.
    831          * Return         : None.
    832          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    833          void CAN_ClearITPendingBit(u32 CAN_IT)
    834          {
    835            /* Check the parameters */
    836            assert_param(IS_CAN_ITStatus(CAN_IT));
    837          
    838            switch (CAN_IT)
   \                     CAN_ClearITPendingBit:
   \   00000000   ....               LDR.N    R1,??DataTable16  ;; 0x40006404
   \   00000002   0428               CMP      R0,#+4
   \   00000004   2DD0               BEQ.N    ??CAN_ClearITPendingBit_0
   \   00000006   0528               CMP      R0,#+5
   \   00000008   1ED0               BEQ.N    ??CAN_ClearITPendingBit_1
   \   0000000A   0628               CMP      R0,#+6
   \   0000000C   20D0               BEQ.N    ??CAN_ClearITPendingBit_2
   \   0000000E   0728               CMP      R0,#+7
   \   00000010   22D0               BEQ.N    ??CAN_ClearITPendingBit_3
   \   00000012   0828               CMP      R0,#+8
   \   00000014   29D0               BEQ.N    ??CAN_ClearITPendingBit_4
   \   00000016   2028               CMP      R0,#+32
   \   00000018   2AD0               BEQ.N    ??CAN_ClearITPendingBit_5
   \   0000001A   4028               CMP      R0,#+64
   \   0000001C   2CD0               BEQ.N    ??CAN_ClearITPendingBit_6
   \   0000001E   4FF48072           MOV      R2,#+256
   \   00000022   9042               CMP      R0,R2
   \   00000024   2BD0               BEQ.N    ??CAN_ClearITPendingBit_7
   \   00000026   4FF40072           MOV      R2,#+512
   \   0000002A   9042               CMP      R0,R2
   \   0000002C   2DD0               BEQ.N    ??CAN_ClearITPendingBit_8
   \   0000002E   4FF48062           MOV      R2,#+1024
   \   00000032   9042               CMP      R0,R2
   \   00000034   2ED0               BEQ.N    ??CAN_ClearITPendingBit_9
   \   00000036   4FF48032           MOV      R2,#+65536
   \   0000003A   9042               CMP      R0,R2
   \   0000003C   30D0               BEQ.N    ??CAN_ClearITPendingBit_10
   \   0000003E   4FF40032           MOV      R2,#+131072
   \   00000042   9042               CMP      R0,R2
   \   00000044   2ED0               BEQ.N    ??CAN_ClearITPendingBit_11
   \   00000046   7047               BX       LR
    839            {
    840              case CAN_IT_RQCP0:
    841                CAN->TSR = TSR_RQCP0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_1:
   \   00000048   0846               MOV      R0,R1
   \   0000004A   0121               MOVS     R1,#+1
   \                     ??CAN_ClearITPendingBit_12:
   \   0000004C   4160               STR      R1,[R0, #+4]
   \   0000004E   7047               BX       LR
    842                break;
    843              case CAN_IT_RQCP1:
    844                CAN->TSR = TSR_RQCP1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_2:
   \   00000050   0846               MOV      R0,R1
   \   00000052   4FF48071           MOV      R1,#+256
   \   00000056   F9E7               B.N      ??CAN_ClearITPendingBit_12
    845                break;
    846              case CAN_IT_RQCP2:
    847                CAN->TSR = TSR_RQCP2; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_3:
   \   00000058   0846               MOV      R0,R1
   \   0000005A   4FF48031           MOV      R1,#+65536
   \   0000005E   4160               STR      R1,[R0, #+4]
   \   00000060   7047               BX       LR
    848                break;
    849              case CAN_IT_FF0:
    850                CAN->RF0R = RF0R_FULL0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_0:
   \   00000062   0846               MOV      R0,R1
   \   00000064   0821               MOVS     R1,#+8
   \                     ??CAN_ClearITPendingBit_13:
   \   00000066   8160               STR      R1,[R0, #+8]
   \   00000068   7047               BX       LR
    851                break;
    852              case CAN_IT_FOV0:
    853                CAN->RF0R = RF0R_FOVR0; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_4:
   \   0000006A   0846               MOV      R0,R1
   \   0000006C   1021               MOVS     R1,#+16
   \   0000006E   FAE7               B.N      ??CAN_ClearITPendingBit_13
    854                break;
    855              case CAN_IT_FF1:
    856                CAN->RF1R = RF1R_FULL1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_5:
   \   00000070   0846               MOV      R0,R1
   \   00000072   0821               MOVS     R1,#+8
   \                     ??CAN_ClearITPendingBit_14:
   \   00000074   C160               STR      R1,[R0, #+12]
   \   00000076   7047               BX       LR
    857                break;
    858              case CAN_IT_FOV1:
    859                CAN->RF1R = RF1R_FOVR1; /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_6:
   \   00000078   0846               MOV      R0,R1
   \   0000007A   1021               MOVS     R1,#+16
   \   0000007C   FAE7               B.N      ??CAN_ClearITPendingBit_14
    860                break;
    861              case CAN_IT_EWG:
    862                CAN->ESR &= ~ ESR_EWGF; /* rw */
   \                     ??CAN_ClearITPendingBit_7:
   \   0000007E   4869               LDR      R0,[R1, #+20]
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   8843               BICS     R0,R0,R1
   \   00000084   ....               LDR.N    R1,??DataTable16  ;; 0x40006404
   \                     ??CAN_ClearITPendingBit_15:
   \   00000086   4861               STR      R0,[R1, #+20]
   \   00000088   7047               BX       LR
    863                break;
    864              case CAN_IT_EPV:
    865                CAN->ESR &= ~ ESR_EPVF; /* rw */
   \                     ??CAN_ClearITPendingBit_8:
   \   0000008A   4869               LDR      R0,[R1, #+20]
   \   0000008C   0221               MOVS     R1,#+2
   \   0000008E   8843               BICS     R0,R0,R1
   \   00000090   ....               LDR.N    R1,??DataTable16  ;; 0x40006404
   \   00000092   F8E7               B.N      ??CAN_ClearITPendingBit_15
    866                break;
    867              case CAN_IT_BOF:
    868                CAN->ESR &= ~ ESR_BOFF; /* rw */
   \                     ??CAN_ClearITPendingBit_9:
   \   00000094   4869               LDR      R0,[R1, #+20]
   \   00000096   0421               MOVS     R1,#+4
   \   00000098   8843               BICS     R0,R0,R1
   \   0000009A   ....               LDR.N    R1,??DataTable16  ;; 0x40006404
   \   0000009C   4861               STR      R0,[R1, #+20]
   \   0000009E   7047               BX       LR
    869                break;
    870              case CAN_IT_WKU:
    871                CAN->MSR = MSR_WKUI;  /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_10:
   \   000000A0   0820               MOVS     R0,#+8
   \   000000A2   00E0               B.N      ??CAN_ClearITPendingBit_16
    872                break;
    873              case CAN_IT_SLK:
    874                CAN->MSR = MSR_SLAKI;  /* rc_w1*/
   \                     ??CAN_ClearITPendingBit_11:
   \   000000A4   1020               MOVS     R0,#+16
   \                     ??CAN_ClearITPendingBit_16:
   \   000000A6   0860               STR      R0,[R1, #+0]
    875                break;
    876              default :
    877                break;
    878            }
    879          }
   \                     ??CAN_ClearITPendingBit_17:
   \   000000A8   7047               BX       LR               ;; return
    880          
    881          /*******************************************************************************
    882          * Function Name  : CheckITStatus
    883          * Description    : Checks whether the CAN interrupt has occurred or not.
    884          * Input          : CAN_Reg: specifies the CAN interrupt register to check.
    885          *                  It_Bit: specifies the interrupt source bit to check.
    886          * Output         : None.
    887          * Return         : The new state of the CAN Interrupt (SET or RESET).
    888          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    889          static ITStatus CheckITStatus(u32 CAN_Reg, u32 It_Bit)
    890          {
    891            ITStatus pendingbitstatus = RESET;
    892          
    893            if ((CAN_Reg & It_Bit) != (u32)RESET)
   \                     CheckITStatus:
   \   00000000   0840               ANDS     R0,R1,R0
   \   00000002   18BF               IT       NE 
   \   00000004   0120               MOVNE    R0,#+1
    894            {
    895              /* CAN_IT is set */
    896              pendingbitstatus = SET;
    897            }
    898            else
    899            {
    900              /* CAN_IT is reset */
    901              pendingbitstatus = RESET;
    902            }
    903          
    904            return pendingbitstatus;
   \   00000006   40B2               SXTB     R0,R0
   \   00000008   7047               BX       LR               ;; return
    905          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   08640040           DC32     0x40006408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0C640040           DC32     0x4000640c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   00640040           DC32     0x40006400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   18640040           DC32     0x40006418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   04640040           DC32     0x40006404
    906          
    907          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     CAN_CancelTransmit         0
     CAN_ClearFlag              0
     CAN_ClearITPendingBit      0
     CAN_DeInit                 0
     CAN_FIFORelease            0
     CAN_FilterInit             0
     CAN_GetFlagStatus          0
     CAN_GetITStatus            0
     CAN_ITConfig               0
     CAN_Init                   0
     CAN_MessagePending         0
     CAN_Receive                0
     CAN_Sleep                  0
     CAN_StructInit             0
     CAN_Transmit               0
     CAN_TransmitStatus         0
     CAN_WakeUp                 0
     CheckITStatus              0


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     CAN_DeInit              26
     CAN_Init               202
     CAN_FilterInit         264
     CAN_StructInit          32
     CAN_ITConfig            24
     CAN_Transmit           276
     CAN_TransmitStatus     128
     CAN_CancelTransmit      40
     CAN_FIFORelease         18
     CAN_MessagePending      30
     CAN_Receive            112
     CAN_Sleep               24
     CAN_WakeUp              24
     CAN_GetFlagStatus       14
     CAN_ClearFlag           12
     CAN_GetITStatus        164
     CAN_ClearITPendingBit  170
     CheckITStatus           10
     ??DataTable3             4
     ??DataTable7             4
     ??DataTable9             4
     ??DataTable11            4
     ??DataTable16            4

 
 1 590 bytes in section .text
 
 1 590 bytes of CODE memory

Errors: none
Warnings: none
